<html>

<head>
    <style>
        html {
            position: relative;
            height: 100%;
        }

        body {
            margin: 0px;
            position: relative;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480" style="width:100%;height:100%"></canvas>
</body>
<script src="../utils/gl-matrix.js">
    //shadow, explain vec4 vec3 (1.0) (0.0)
    // should split into 3 sections
    // 1. visualization/spotlight
    // 2. dump depth map
    // 3. shadow
    // 4. remove artifact
    // 5. use comparison sampler?
</script>
<script src="../utils/OBJFile.js"> </script>
<script src="../utils/utils.js"></script>
<script src="../utils/helper.js"></script>

<script id="object_with_shadow_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    @group(0) @binding(2)
    var<uniform> normalMatrix: mat4x4<f32>;
    @group(0) @binding(3) 
    var<uniform> lightDirection: vec3<f32>;
    @group(0) @binding(4)
    var<uniform> viewDirection: vec3<f32>;
    
    @group(0) @binding(5)
    var<uniform> ambientColor:vec4<f32>;// = vec4<f32>(0.15, 0.10, 0.10, 1.0);
    @group(0) @binding(6)
    var<uniform> diffuseColor:vec4<f32>;// = vec4<f32>(0.55, 0.55, 0.55, 1.0);
    @group(0) @binding(7)
    var<uniform> specularColor:vec4<f32>;// = vec4<f32>(1.0, 1.0, 1.0, 1.0);
    
    @group(0) @binding(8)
    var<uniform> shininess:f32;// = 20.0;
        
    const diffuseConstant:f32 = 1.0;
    const specularConstant:f32 = 1.0;
    const ambientConstant: f32 = 1.0;
    
    fn specular(lightDir:vec3<f32>, viewDir:vec3<f32>, normal:vec3<f32>,  specularColor:vec3<f32>, 
         shininess:f32) -> vec3<f32> {
        let reflectDir:vec3<f32> = reflect(-lightDir, normal);
        let specDot:f32 = max(dot(reflectDir, viewDir), 0.0);
        return pow(specDot, shininess) * specularColor;
    }
    
    fn diffuse(lightDir:vec3<f32>, normal:vec3<f32>,  diffuseColor:vec3<f32>) -> vec3<f32>{
        return max(dot(lightDir, normal), 0.0) * diffuseColor;
    }
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) viewDir: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) lightDir: vec3<f32>,
        @location(3) wldLoc: vec3<f32>,
        @location(4) lightLoc: vec3<f32>,
        @location(5) inPos: vec3<f32>
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>,
        @location(1) inNormal: vec3<f32>
    ) -> VertexOutput {
        var out: VertexOutput;
    
        out.viewDir = normalize((normalMatrix * vec4<f32>(-viewDirection, 0.0)).xyz);
        out.lightDir = normalize((normalMatrix * vec4<f32>(-lightDirection, 0.0)).xyz);
        out.normal = normalize(normalMatrix * vec4<f32>(inNormal, 0.0)).xyz;  
        var wldLoc:vec4<f32> = modelView * vec4<f32>(inPos, 1.0);
        out.clip_position = projection * wldLoc;
        out.wldLoc = wldLoc.xyz / wldLoc.w;
        out.inPos = inPos;
        var lightLoc:vec4<f32> = modelView * vec4<f32>(lightDirection, 1.0);
        out.lightLoc = lightLoc.xyz / lightLoc.w;

        return out;
    }
    
    // Fragment shader
    @group(0) @binding(9)
    var t_depth: texture_depth_2d;
    @group(0) @binding(10)
    var s_depth: sampler_comparison;
    @group(0) @binding(11)
    var<uniform> lightModelViewMatrix: mat4x4<f32>;
    @group(0) @binding(12)
    var<uniform> lightProjectionMatrix: mat4x4<f32>;

    @fragment
    fn fs_main(in: VertexOutput,   @builtin(front_facing) face: bool) -> @location(0) vec4<f32> {
        var lightLoc:vec3<f32> = in.lightLoc;
        var lightDir:vec3<f32> = normalize(in.lightDir);
        var n:vec3<f32> = normalize(in.normal);
        var viewDir: vec3<f32> = in.viewDir;

        var fragmentPosInScreenSpace: vec4<f32> = lightProjectionMatrix * lightModelViewMatrix * vec4(in.inPos, 1.0);
        fragmentPosInScreenSpace = fragmentPosInScreenSpace / fragmentPosInScreenSpace.w;
        var depth: f32 = fragmentPosInScreenSpace.z;
        var uv:vec2<f32> = 0.5*(fragmentPosInScreenSpace.xy + vec2(1.0,1.0));

        var visibility = 0.0;
            let oneOverShadowDepthTextureSize = 1.0 / 1024.0;
            for (var y = -2; y <= 2; y++) {
              for (var x = -2; x <= 2; x++) {
                let offset = vec2<f32>(vec2(x, y)) * oneOverShadowDepthTextureSize;
          
                visibility += textureSampleCompare(
                    t_depth, s_depth,
                    vec2(uv.x, 1.0-uv.y) + offset,depth  - 0.0003
                );
              }
            }
            visibility /= 25.0;


        //var light2ClosestSurfaceDist = textureSample(t_depth, s_depth, vec2(uv.x, 1.0-uv.y));
        if (face) {
            //if (depth < light2ClosestSurfaceDist+0.0001) {

                var wldLoc2light:vec3<f32> =   in.wldLoc-lightLoc;

                //var lightDir:vec3<f32> =  
                var align:f32 = dot( normalize(wldLoc2light),lightDir);

                if (align > 0.9) {
                    var radiance:vec3<f32>  = ambientColor.rgb * ambientConstant + 
                        diffuse(-lightDir, n, diffuseColor.rgb)* diffuseConstant +
                        specular(-lightDir, viewDir, n, specularColor.rgb, shininess) * specularConstant;
        
                    return vec4<f32>(radiance * visibility ,1.0);
                   // return vec4<f32>(0.0,0.0,light2ClosestSurfaceDist,1.0);
                }

                //return vec4<f32>(1.0,1.0,0.0,1.0);
            //}
          
        } 
        return vec4<f32>( 0.0,0.0,0.0,1.0);
    }
</script>

<script id="object_with_shadow_ani_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    @group(0) @binding(2)
    var<uniform> normalMatrix: mat4x4<f32>;
    @group(0) @binding(3) 
    var<uniform> lightDirection: vec3<f32>;
    @group(0) @binding(4)
    var<uniform> viewDirection: vec3<f32>;
    
    @group(0) @binding(5)
    var<uniform> ambientColor:vec4<f32>;// = vec4<f32>(0.15, 0.10, 0.10, 1.0);
    @group(0) @binding(6)
    var<uniform> diffuseColor:vec4<f32>;// = vec4<f32>(0.55, 0.55, 0.55, 1.0);
    @group(0) @binding(7)
    var<uniform> specularColor:vec4<f32>;// = vec4<f32>(1.0, 1.0, 1.0, 1.0);
    
    @group(0) @binding(8)
    var<uniform> shininess:f32;// = 20.0;

    @group(1) @binding(0)
    var<uniform> boneTransforms: array<mat4x4<f32>, 16>;
        
    const diffuseConstant:f32 = 1.0;
    const specularConstant:f32 = 1.0;
    const ambientConstant: f32 = 1.0;
    
    fn specular(lightDir:vec3<f32>, viewDir:vec3<f32>, normal:vec3<f32>,  specularColor:vec3<f32>, 
         shininess:f32) -> vec3<f32> {
        let reflectDir:vec3<f32> = reflect(-lightDir, normal);
        let specDot:f32 = max(dot(reflectDir, viewDir), 0.0);
        return pow(specDot, shininess) * specularColor;
    }
    
    fn diffuse(lightDir:vec3<f32>, normal:vec3<f32>,  diffuseColor:vec3<f32>) -> vec3<f32>{
        return max(dot(lightDir, normal), 0.0) * diffuseColor;
    }
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) viewDir: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) lightDir: vec3<f32>,
        @location(3) wldLoc: vec3<f32>,
        @location(4) lightLoc: vec3<f32>,
        @location(5) inPos: vec3<f32>
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>,
        @location(1) inNormal: vec3<f32>,
        @location(2) boneWeight0: vec4<f32>,
        @location(3) boneWeight1: vec4<f32>,
        @location(4) boneWeight2: vec4<f32>,
        @location(5) boneWeight3: vec4<f32>
    ) -> VertexOutput {
        var out: VertexOutput;
        var totalTransform:mat4x4<f32> = mat4x4<f32>(0.0,0.0,0.0,0.0,
            0.0,0.0,0.0,0.0,
            0.0,0.0,0.0,0.0,
            0.0,0.0,0.0,0.0);
        var totalPos :vec4<f32>= vec4<f32>(0.0,0.0,0.0,0.0);
        
            totalPos += boneTransforms[0] * vec4<f32>(inPos, 1.0) * boneWeight0[0];
            totalPos += boneTransforms[1] * vec4<f32>(inPos, 1.0)* boneWeight0[1];
            totalPos += boneTransforms[2] * vec4<f32>(inPos, 1.0)* boneWeight0[2];
            totalPos += boneTransforms[3] * vec4<f32>(inPos, 1.0)* boneWeight0[3];
            totalPos += boneTransforms[4] * vec4<f32>(inPos, 1.0)* boneWeight1[0];
            totalPos += boneTransforms[5] * vec4<f32>(inPos, 1.0)* boneWeight1[1];
            totalPos += boneTransforms[6] * vec4<f32>(inPos, 1.0)* boneWeight1[2];
            totalPos += boneTransforms[7] * vec4<f32>(inPos, 1.0)* boneWeight1[3];
            totalPos += boneTransforms[8] * vec4<f32>(inPos, 1.0)* boneWeight2[0];
            totalPos += boneTransforms[9] * vec4<f32>(inPos, 1.0)* boneWeight2[1];
            totalPos += boneTransforms[10] * vec4<f32>(inPos, 1.0)* boneWeight2[2];
            totalPos += boneTransforms[11] * vec4<f32>(inPos, 1.0)* boneWeight2[3];
            totalPos += boneTransforms[12] * vec4<f32>(inPos, 1.0)* boneWeight3[0];

    
        out.viewDir = normalize((normalMatrix * vec4<f32>(-viewDirection, 0.0)).xyz);
        out.lightDir = normalize((normalMatrix * vec4<f32>(-lightDirection, 0.0)).xyz);
        out.normal = normalize(normalMatrix * vec4<f32>(inNormal, 0.0)).xyz;  
        var wldLoc:vec4<f32> = modelView  * vec4<f32>(totalPos.xyz, 1.0);
        out.clip_position = projection * wldLoc;
        out.wldLoc = wldLoc.xyz / wldLoc.w;
        out.inPos = inPos;
        var lightLoc:vec4<f32> = modelView * vec4<f32>(lightDirection, 1.0);
        out.lightLoc = lightLoc.xyz / lightLoc.w;

        return out;
    }
    
    // Fragment shader
    @group(0) @binding(9)
    var t_depth: texture_depth_2d;
    @group(0) @binding(10)
    var s_depth: sampler_comparison;
    @group(0) @binding(11)
    var<uniform> lightModelViewMatrix: mat4x4<f32>;
    @group(0) @binding(12)
    var<uniform> lightProjectionMatrix: mat4x4<f32>;

    @fragment
    fn fs_main(in: VertexOutput,   @builtin(front_facing) face: bool) -> @location(0) vec4<f32> {
        var lightLoc:vec3<f32> = in.lightLoc;
        var lightDir:vec3<f32> = normalize(in.lightDir);
        var n:vec3<f32> = normalize(in.normal);
        var viewDir: vec3<f32> = in.viewDir;

        var fragmentPosInScreenSpace: vec4<f32> = lightProjectionMatrix * lightModelViewMatrix * vec4(in.inPos, 1.0);
        fragmentPosInScreenSpace = fragmentPosInScreenSpace / fragmentPosInScreenSpace.w;
        var depth: f32 = fragmentPosInScreenSpace.z;
        var uv:vec2<f32> = 0.5*(fragmentPosInScreenSpace.xy + vec2(1.0,1.0));

        var visibility = 0.0;
            let oneOverShadowDepthTextureSize = 1.0 / 1024.0;
            for (var y = -2; y <= 2; y++) {
              for (var x = -2; x <= 2; x++) {
                let offset = vec2<f32>(vec2(x, y)) * oneOverShadowDepthTextureSize;
          
                visibility += textureSampleCompare(
                    t_depth, s_depth,
                    vec2(uv.x, 1.0-uv.y) + offset,depth  - 0.0003
                );
              }
            }
            visibility /= 25.0;


        //var light2ClosestSurfaceDist = textureSample(t_depth, s_depth, vec2(uv.x, 1.0-uv.y));
        if (face) {
            //if (depth < light2ClosestSurfaceDist+0.0001) {

                var wldLoc2light:vec3<f32> =   in.wldLoc-lightLoc;

                //var lightDir:vec3<f32> =  
                var align:f32 = dot( normalize(wldLoc2light),lightDir);

                if (align > 0.9) {
                    var radiance:vec3<f32>  = ambientColor.rgb * ambientConstant + 
                        diffuse(-lightDir, n, diffuseColor.rgb)* diffuseConstant +
                        specular(-lightDir, viewDir, n, specularColor.rgb, shininess) * specularConstant;
        
                    return vec4<f32>(radiance * visibility ,1.0);
                   // return vec4<f32>(0.0,0.0,light2ClosestSurfaceDist,1.0);
                }

                //return vec4<f32>(1.0,1.0,0.0,1.0);
            //}
          
        } 
        return vec4<f32>( 0.0,0.0,0.0,1.0);
    }
</script>

<script id="light_view_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;

    @group(1) @binding(0)
    var<uniform> boneTransforms: array<mat4x4<f32>, 16>;
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) depth: f32
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>,
        @location(1) boneWeight0: vec4<f32>,
        @location(2) boneWeight1: vec4<f32>,
        @location(3) boneWeight2: vec4<f32>,
        @location(4) boneWeight3: vec4<f32>
    ) -> VertexOutput {
        var out: VertexOutput;

        var wldLoc:vec4<f32> = modelView * vec4<f32>(inPos, 1.0);
        out.clip_position = projection * wldLoc;
        out.depth = out.clip_position.z / out.clip_position.w;
        return out;
    }

    struct FragOutputs {
        @builtin(frag_depth) depth: f32,
        @location(0) color: vec4<f32>
      }
    
    // Fragment shader
    @fragment
    fn fs_main(in: VertexOutput,   @builtin(front_facing) isFront: bool) -> FragOutputs {
        var out:FragOutputs;
        if (isFront) {
            out.depth = in.depth;
        }
        else {
            out.depth = in.depth -0.001;
        }
        out.color = vec4<f32>(0.0,1.0,0.0,1.0);
        return out;
    }
</script>

<script>
    let angle = 0.0;
    class Plane {
        constructor() {
            this.pipeline = null;
            this.positionBuffer = null;
            this.normalBuffer = null;
            this.indexBuffer = null;
            this.uniformBindGroup = null;
            this.indexSize = null;
        }

        async setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            depthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer) {
            let shaderModule = shaderModuleFromCode(device, 'object_with_shadow_shader')

            let positions = new Float32Array([
                -100, -100, 0,
                100, -100, 0,
                -100, 100, 0,
                100, 100, 0
            ]);

            let normals = new Float32Array([
                0, 0, 1,
                0, 0, 1,
                0, 0, 1,
                0, 0, 1
            ]);

            this.positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);
            this.normalBuffer = createGPUBuffer(device, normals, GPUBufferUsage.VERTEX);

            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 4,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 5,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 6,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 7,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 8,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 9,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {
                            sampleType: "depth"
                        }
                    },
                    {
                        binding: 10,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {
                            type: 'comparison',
                        },
                    },
                    {
                        binding: 11,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 12,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    }
                ]
            });

            const ambientUniformBuffer = createGPUBuffer(device, new Float32Array([0.15, 0.10, 0.10, 1.0]), GPUBufferUsage.UNIFORM);
            const diffuseUniformBuffer = createGPUBuffer(device, new Float32Array([0.55, 0.55, 0.55, 1.0]), GPUBufferUsage.UNIFORM);
            const specularUniformBuffer = createGPUBuffer(device, new Float32Array([0.0, 0.0, 0.0, 1.0]), GPUBufferUsage.UNIFORM);
            const shininessUniformBuffer = createGPUBuffer(device, new Float32Array([0.0]), GPUBufferUsage.UNIFORM);


            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: modelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: normalMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: lightDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 4,
                        resource: {
                            buffer: viewDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 5,
                        resource: {
                            buffer: ambientUniformBuffer
                        }
                    },
                    {
                        binding: 6,
                        resource: {
                            buffer: diffuseUniformBuffer
                        }
                    },
                    {
                        binding: 7,
                        resource: {
                            buffer: specularUniformBuffer
                        }
                    },
                    {
                        binding: 8,
                        resource: {
                            buffer: shininessUniformBuffer
                        }
                    },
                    {
                        binding: 9,
                        resource: depthTexture.createView()
                    },
                    {
                        binding: 10,
                        resource:
                            sampler
                    },
                    {
                        binding: 11,
                        resource: {
                            buffer: lightModelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 12,
                        resource: {
                            buffer: lightProjectionMatrixUniformBuffer
                        }
                    },
                ]
            });

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x3'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const normalAttribDesc = {
                shaderLocation: 1, // @location(1)
                offset: 0,
                format: 'float32x3'
            };

            const normalBufferLayoutDesc = {
                attributes: [normalAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, normalBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-strip',
                    frontFace: 'ccw',
                    cullMode: 'none'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);
        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.normalBuffer);
            encoder.draw(4, 1);
        }
    }

    class RunCube {
        constructor() {
            this.pipeline = null;
            this.lightPipeline = null;
            this.positionBuffer = null;
            this.boneWeightBuffer = null;
            this.indexBuffer = null;
            this.uniformBindGroup = null;
            this.indexSize = null;
            this.uniformBindGroupLight = null;
        }

        async setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            depthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer) {
            let shaderModule = shaderModuleFromCode(device, 'object_with_shadow_ani_shader');
            let shaderModuleLight = shaderModuleFromCode(device, 'light_view_shader');

            const objResponse = await fetch('../data/cuberun.json');
            const objBody = await objResponse.json();

            console.log(objBody);

            let boneWeights = new Float32Array(objBody.vert.length * 16 / 3);

            function assignBoneWeightsToVerticesHelper(bone, boneWeights) {
                for (let i = 0; i < bone.weights.length; ++i) {
                    const { id, w } = bone.weights[i];
                    boneWeights[id * 16 + bone.id] = w;
                }

                if (bone.children.length > 0) {
                    for (let i = 0; i < bone.children.length; ++i) {
                        assignBoneWeightsToVerticesHelper(bone.children[i], boneWeights);
                    }
                }
            }

            for (let i = 0; i < objBody.skeleton.length; ++i) {
                assignBoneWeightsToVerticesHelper(objBody.skeleton[i], boneWeights);
            }

            console.log("assigned bone weights", boneWeights);

            let boneTransforms = new Float32Array(16 * 16);
            const frameId = 0;

            function deriveBoneTransformHelper(bone, parentTransform) {

                const offsetMatrix = glMatrix.mat4.fromValues(bone.offsetMatrix[0], bone.offsetMatrix[4], bone.offsetMatrix[8],
                    bone.offsetMatrix[12],
                    bone.offsetMatrix[1],
                    bone.offsetMatrix[5],
                    bone.offsetMatrix[9],
                    bone.offsetMatrix[13],
                    bone.offsetMatrix[2],
                    bone.offsetMatrix[6],
                    bone.offsetMatrix[10],
                    bone.offsetMatrix[14],
                    bone.offsetMatrix[3],
                    bone.offsetMatrix[7],
                    bone.offsetMatrix[11],
                    bone.offsetMatrix[15]);

                if (bone.ani) {
                    const translationMatrix = glMatrix.mat4.fromTranslation(glMatrix.mat4.create(),
                        glMatrix.vec3.fromValues(bone.ani.pos[frameId].pos[0], bone.ani.pos[frameId].pos[1], bone.ani.pos[frameId].pos[2]));

                    const quat = glMatrix.quat.fromValues(bone.ani.rot[frameId].q[1], bone.ani.rot[frameId].q[2], bone.ani.rot[frameId].q[3], bone.ani.rot[frameId].q[0]);

                    const rotationMatrix = glMatrix.mat4.fromQuat(glMatrix.mat4.create(), quat);

                    const scalingMatrix = glMatrix.mat4.fromScaling(glMatrix.mat4.create(),
                        glMatrix.vec3.fromValues(
                            bone.ani.scal[frameId].pos[0], bone.ani.scal[frameId].pos[1], bone.ani.scal[frameId].pos[2]));


                    const rotation_x_scale = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                        rotationMatrix, scalingMatrix);

                    const locationTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                        translationMatrix, rotation_x_scale);

                    const globalTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                        parentTransform, locationTransformation);

                    const finalBoneTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                        globalTransformation, offsetMatrix);

                    boneTransforms.set(glMatrix.mat4.multiply(glMatrix.mat4.create(), parentTransform, offsetMatrix), bone.id * 16);


                    if (bone.children.length > 0) {
                        for (let i = 0; i < bone.children.length; ++i) {
                            deriveBoneTransformHelper(bone.children[i], parentTransform);
                        }
                    }
                }
                else {

                    boneTransforms.set(glMatrix.mat4.multiply(glMatrix.mat4.create(), parentTransform, offsetMatrix), bone.id * 16);
                }
            }

            for (let i = 0; i < objBody.skeleton.length; ++i) {
                deriveBoneTransformHelper(objBody.skeleton[i], glMatrix.mat4.identity(glMatrix.mat4.create()));
            }

            console.log("bone transformation", boneTransforms);

            let boneTransformUniformBuffer = createGPUBuffer(device, boneTransforms, GPUBufferUsage.UNIFORM);

            /*let max = 0;
            for(let i =0;i<objBody.vert.length/3;++i){
                let count = 0;
                for(let e =0;e<16;++e){
                    if (boneWeights[i*16 + e] > 0){
                        count++;
                    }
                }

                if (count > max) {
                    max = count;
                }
            }

            console.log("max bone", max);*/

            this.boneWeightBuffer = createGPUBuffer(device, boneWeights, GPUBufferUsage.VERTEX);
            this.positionBuffer = createGPUBuffer(device, new Float32Array(objBody.vert), GPUBufferUsage.VERTEX);

            this.indexSize = objBody.indices.length;
            this.indexBuffer = createGPUBuffer(device, new Uint16Array(objBody.indices), GPUBufferUsage.INDEX);

            let uniformBindGroupLayoutLight = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    }
                ]
            });

            this.uniformBindGroupLight = device.createBindGroup({
                layout: uniformBindGroupLayoutLight,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: lightModelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: lightProjectionMatrixUniformBuffer
                        }
                    }
                ]
            });

            let uniformBindGroupLayoutBone = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    }
                ]
            });

            this.uniformBindGroupBone = device.createBindGroup({
                layout: uniformBindGroupLayoutBone,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: boneTransformUniformBuffer
                        }
                    }
                ]
            });

            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 4,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 5,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 6,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 7,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 8,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 9,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {
                            sampleType: "depth"
                        }
                    },
                    {
                        binding: 10,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {
                            type: 'comparison',
                        },
                    },
                    {
                        binding: 11,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 12,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    }
                ]
            });

            const ambientUniformBuffer = createGPUBuffer(device, new Float32Array([0.15, 0.10, 0.10, 1.0]), GPUBufferUsage.UNIFORM);
            const diffuseUniformBuffer = createGPUBuffer(device, new Float32Array([0.55, 0.55, 0.55, 1.0]), GPUBufferUsage.UNIFORM);
            const specularUniformBuffer = createGPUBuffer(device, new Float32Array([1.0, 1.0, 1.0, 1.0]), GPUBufferUsage.UNIFORM);
            const shininessUniformBuffer = createGPUBuffer(device, new Float32Array([20.0]), GPUBufferUsage.UNIFORM);


            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: modelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: normalMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: lightDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 4,
                        resource: {
                            buffer: viewDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 5,
                        resource: {
                            buffer: ambientUniformBuffer
                        }
                    },
                    {
                        binding: 6,
                        resource: {
                            buffer: diffuseUniformBuffer
                        }
                    },
                    {
                        binding: 7,
                        resource: {
                            buffer: specularUniformBuffer
                        }
                    },
                    {
                        binding: 8,
                        resource: {
                            buffer: shininessUniformBuffer
                        }
                    },
                    {
                        binding: 9,
                        resource: depthTexture.createView()
                    },
                    {
                        binding: 10,
                        resource:
                            sampler
                    },
                    {
                        binding: 11,
                        resource: {
                            buffer: lightModelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 12,
                        resource: {
                            buffer: lightProjectionMatrixUniformBuffer
                        }
                    },
                ]
            });

            const positionAttribDesc = {
                shaderLocation: 0,
                offset: 0,
                format: 'float32x3'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 6,
                stepMode: 'vertex'
            };

            const normalAttribDesc = {
                shaderLocation: 1,
                offset: 4 * 3,
                format: 'float32x3'
            };

            const normalBufferLayoutDesc = {
                attributes: [normalAttribDesc],
                arrayStride: 4 * 6,
                stepMode: 'vertex'
            };

            const boneWeight0AttribDesc = {
                shaderLocation: 2,
                offset: 0,
                format: 'float32x4'
            };

            const boneWeight1AttribDesc = {
                shaderLocation: 3,
                offset: 4 * 4,
                format: 'float32x4'
            };

            const boneWeight2AttribDesc = {
                shaderLocation: 4,
                offset: 4 * 8,
                format: 'float32x4'
            };

            const boneWeight3AttribDesc = {
                shaderLocation: 5,
                offset: 4 * 12,
                format: 'float32x4'
            };

            const boneWeightBufferLayoutDesc = {
                attributes: [boneWeight0AttribDesc, boneWeight1AttribDesc, boneWeight2AttribDesc, boneWeight3AttribDesc],
                arrayStride: 4 * 16,
                stepMode: 'vertex'
            };

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout, uniformBindGroupLayoutBone] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc,
                        normalBufferLayoutDesc,
                        boneWeightBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-list',
                    frontFace: 'ccw',
                    cullMode: 'none'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);

            const lightPipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayoutLight, uniformBindGroupLayoutBone] };

            const lightBoneWeight0AttribDesc = {
                shaderLocation: 1,
                offset: 0,
                format: 'float32x4'
            };

            const lightBoneWeight1AttribDesc = {
                shaderLocation: 2,
                offset: 4 * 4,
                format: 'float32x4'
            };

            const lightBoneWeight2AttribDesc = {
                shaderLocation: 3,
                offset: 4 * 8,
                format: 'float32x4'
            };

            const lightBoneWeight3AttribDesc = {
                shaderLocation: 4,
                offset: 4 * 12,
                format: 'float32x4'
            };

            const lightBoneWeightBufferLayoutDesc = {
                attributes: [lightBoneWeight0AttribDesc, lightBoneWeight1AttribDesc, lightBoneWeight2AttribDesc, lightBoneWeight3AttribDesc],
                arrayStride: 4 * 16,
                stepMode: 'vertex'
            };

            const lightPipelineDesc = {
                layout: device.createPipelineLayout(lightPipelineLayoutDesc),
                vertex: {
                    module: shaderModuleLight,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc,
                        lightBoneWeightBufferLayoutDesc
                    ]
                },
                fragment: {
                    module: shaderModuleLight,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-list',
                    frontFace: 'ccw',
                    cullMode: 'none'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.lightPipeline = device.createRenderPipeline(lightPipelineDesc);
        }

        encodeForLight(encoder) {
            encoder.setPipeline(this.lightPipeline);
            encoder.setBindGroup(0, this.uniformBindGroupLight);
            encoder.setBindGroup(1, this.uniformBindGroupBone);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.boneWeightBuffer);
            encoder.setIndexBuffer(this.indexBuffer, 'uint16');
            encoder.drawIndexed(this.indexSize);
        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setBindGroup(1, this.uniformBindGroupBone);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.positionBuffer);
            encoder.setVertexBuffer(2, this.boneWeightBuffer);
            encoder.setIndexBuffer(this.indexBuffer, 'uint16');
            encoder.drawIndexed(this.indexSize);
        }
    }

    class Arcball {
        constructor() {
            this.radius = 15.0;
            this.forwardVector = glMatrix.vec4.fromValues(this.radius, 0.0, 0.0, 0.0);
            this.upVector = glMatrix.vec4.fromValues(0.0, 0.0, 1.0, 0.0);
            this.currentRotation = glMatrix.mat4.create();
        }

        yawPitch(originalX, originalY, currentX, currentY) {

            let originalPoint = glMatrix.vec3.fromValues(1.0, originalX, originalY);
            let newPoint = glMatrix.vec3.fromValues(1.0, currentX, currentY);

            let rotationAxis = glMatrix.vec3.cross(glMatrix.vec3.create(), originalPoint, newPoint);

            rotationAxis = glMatrix.vec4.fromValues(rotationAxis[0], rotationAxis[1], rotationAxis[2], 0.0);

            rotationAxis = glMatrix.vec4.transformMat4(glMatrix.mat4.create(), rotationAxis, this.currentRotation);

            rotationAxis = glMatrix.vec3.normalize(glMatrix.vec3.create(), glMatrix.vec3.fromValues(rotationAxis[0], rotationAxis[1], rotationAxis[2]));

            let sin = glMatrix.vec3.length(rotationAxis) / (glMatrix.vec3.length(originalPoint) * glMatrix.vec3.length(newPoint));

            let rotationMatrix = glMatrix.mat4.fromRotation(glMatrix.mat4.create(), Math.asin(sin) * -0.03, rotationAxis);

            if (rotationMatrix !== null) {
                this.currentRotation = glMatrix.mat4.multiply(glMatrix.mat4.create(), rotationMatrix, this.currentRotation);
                this.forwardVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.forwardVector, rotationMatrix);
                this.upVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.upVector, rotationMatrix);
            }
        }

        roll(originalX, originalY, currentX, currentY) {

            const originalVec = glMatrix.vec3.fromValues(originalX, originalY, 0.0);
            const currentVec = glMatrix.vec3.fromValues(currentX, currentY, 0.0);

            const crossProd = glMatrix.vec3.cross(glMatrix.vec3.create(), originalVec, currentVec);


            let rad = glMatrix.vec3.dot(glMatrix.vec3.normalize(glMatrix.vec3.create(), originalVec),
                glMatrix.vec3.normalize(glMatrix.vec3.create(), currentVec));

            if (rad > 1.0) {
                // cross product can be larger than 1.0 due to numerical error
                rad = Math.PI * Math.sign(crossProd[2]);
            }
            else {
                rad = Math.acos(rad) * Math.sign(crossProd[2]);
            }

            let rotationMatrix = glMatrix.mat4.fromRotation(glMatrix.mat4.create(), -rad, this.forwardVector);
            if (rotationMatrix !== null) {
                this.currentRotation = glMatrix.mat4.multiply(glMatrix.mat4.create(), rotationMatrix, this.currentRotation);
                this.upVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.upVector, rotationMatrix);
            }
        }

        getMatrices() {
            let modelViewMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
                glMatrix.vec3.fromValues(this.forwardVector[0], this.forwardVector[1], this.forwardVector[2]),
                glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(this.upVector[0], this.upVector[1], this.upVector[2]));

            return modelViewMatrix;
        }
    }

    async function webgpu() {
        const adapter = await navigator.gpu.requestAdapter();

        let device = await adapter.requestDevice();

        let context = configContext(device, canvas);

        const sampler = device.createSampler({
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
            compare: "less",
        });

        const lightDepthTextureDesc = {
            size: [1024, 1024, 1],
            dimension: '2d',
            format: 'depth32float',
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING
        };

        let lightDepthTexture = device.createTexture(lightDepthTextureDesc);

        let arcball = new Arcball();

        let modelViewMatrix = arcball.getMatrices();

        let modelViewMatrixUniformBuffer = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let viewDir = glMatrix.vec3.fromValues(- 10.0, -10.0, -10);

        let viewDirectionUniformBuffer = createGPUBuffer(device, viewDir, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let lightDirectionUniformBuffer = createGPUBuffer(device, viewDir, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);


        let modelViewMatrixInverse = glMatrix.mat4.invert(glMatrix.mat4.create(), modelViewMatrix);

        let normalMatrix = glMatrix.mat4.transpose(glMatrix.mat4.create(), modelViewMatrixInverse);

        let normalMatrixUniformBuffer = createGPUBuffer(device, normalMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let projectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
            1.4, 640.0 / 480.0, 0.1, 1000.0);

        let projectionMatrixUniformBuffer = createGPUBuffer(device, projectionMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);


        let lightProjectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
            Math.acos(0.9) * 2.0, 1.0, 1.0, 100.0);

        let lightProjectionMatrixUniformBuffer = createGPUBuffer(device, lightProjectionMatrix, GPUBufferUsage.UNIFORM);

        let lightModelViewMatrixUniformBuffer = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let runCube = new RunCube();
        await runCube.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            lightDepthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer);

        let plane = new Plane();
        await plane.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            lightDepthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer);

        let axis = new Axis();
        await axis.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer);

        let arrow = new Arrow();
        await arrow.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer);

        let dot = new Dot();
        await dot.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer);

        let spotlight = new SpotLight();
        await spotlight.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer);
        let spotLightId = spotlight.upsertSpotLight(null, glMatrix.vec3.fromValues(3.0, 3.0, 2.0), glMatrix.vec3.fromValues(1.0, 1.0, 1.0), glMatrix.vec3.fromValues(0.0, 1.0, 0.0));


        /*dot.upsertDot(null, glMatrix.vec3.fromValues(2.0,2.0,2.0), glMatrix.vec3.fromValues(0.0,1.0,1.0));

        dot.upsertDot(null, glMatrix.vec3.fromValues(-2.0,-2.0,2.0), glMatrix.vec3.fromValues(1.0,1.0,0.0));

        dot.refreshBuffer(device);*/



        let depthTexture = null;


        let lightDepthAttachment = {
            view: lightDepthTexture.createView(),
            depthClearValue: 1,
            depthLoadOp: 'clear',
            depthStoreOp: 'store'
        };

        const lightColorTextureDesc = {
            size: [1024, 1024, 1],
            dimension: '2d',
            format: 'bgra8unorm',
            usage: GPUTextureUsage.RENDER_ATTACHMENT
        };

        let lightColorTexture = device.createTexture(lightColorTextureDesc);

        let lightColorAttachment = {
            view: lightColorTexture.createView(),
            clearValue: { r: 1, g: 0, b: 0, a: 1 },
            loadOp: "load",
            storeOp: 'store'
        }

        const lightRenderPassDesc = {
            colorAttachments: [lightColorAttachment],
            depthStencilAttachment: lightDepthAttachment
        };

        let copiedBuffer = createGPUBuffer(device, new Float32Array(1024 * 1024), GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);
        let hasDumped = true;
        async function render() {
            const devicePixelRatio = window.devicePixelRatio || 1;
            let currentCanvasWidth = canvas.clientWidth * devicePixelRatio;
            let currentCanvasHeight = canvas.clientHeight * devicePixelRatio;

            let projectionMatrixUniformBufferUpdate = null;

            if (depthTexture === null || currentCanvasWidth != canvas.width || currentCanvasHeight != canvas.height) {
                canvas.width = currentCanvasWidth;
                canvas.height = currentCanvasHeight;

                if (depthTexture !== null) {
                    depthTexture.destroy();
                }

                const depthTextureDesc = {
                    size: [canvas.width, canvas.height, 1],
                    dimension: '2d',
                    format: 'depth32float',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                };

                depthTexture = device.createTexture(depthTextureDesc);
                let depthTextureView = depthTexture.createView();

                depthAttachment = {
                    view: depthTextureView,
                    depthClearValue: 1,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store'
                };

                let projectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
                    1.4, canvas.width / canvas.height, 0.1, 1000.0);

                projectionMatrixUniformBufferUpdate = createGPUBuffer(device, projectionMatrix, GPUBufferUsage.COPY_SRC);
            }

            let modelViewMatrix = arcball.getMatrices();

            let modelViewMatrixUniformBufferUpdate = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.COPY_SRC);

            let modelViewMatrixInverse = glMatrix.mat4.invert(glMatrix.mat4.create(), modelViewMatrix);

            let normalMatrix = glMatrix.mat4.transpose(glMatrix.mat4.create(), modelViewMatrixInverse);

            let normalMatrixUniformBufferUpdate = createGPUBuffer(device, normalMatrix, GPUBufferUsage.COPY_SRC);

            let viewDir = glMatrix.vec3.fromValues(-arcball.forwardVector[0], -arcball.forwardVector[1], -arcball.forwardVector[2]);
            let viewDirectionUniformBufferUpdate = createGPUBuffer(device, viewDir, GPUBufferUsage.COPY_SRC);

            let lightDir = glMatrix.vec3.fromValues(Math.cos(angle) * 8.0, Math.sin(angle) * 8.0, 10);
            let lightDirectionUniformBufferUpdate = createGPUBuffer(device, lightDir, GPUBufferUsage.COPY_SRC);
            spotlight.upsertSpotLight(spotLightId, lightDir, glMatrix.vec3.fromValues(-Math.cos(angle) * 8.0, -Math.sin(angle) * 8.0, -10), glMatrix.vec3.fromValues(0.0, 1.0, 0.0));
            spotlight.refreshBuffer(device);

            //console.log("spot light dis:", glMatrix.vec3.length(glMatrix.vec3.fromValues(-Math.cos(angle) * 8.0, -Math.sin(angle) * 8.0, -10)));

            let lightModelViewMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
                glMatrix.vec3.fromValues(Math.cos(angle) * 8.0, Math.sin(angle) * 8.0, 10),
                glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(0.0, 0.0, 1.0));

            let lightModelViewMatrixUniformBufferUpdate = createGPUBuffer(device, lightModelViewMatrix, GPUBufferUsage.COPY_SRC);


            let colorTexture = context.getCurrentTexture();
            let colorTextureView = colorTexture.createView();

            let colorAttachment = {
                view: colorTextureView,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
            };

            let colorAttachment2 = {
                view: colorTextureView,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: "load",
                storeOp: 'store'
            }

            const renderPassDesc = {
                colorAttachments: [colorAttachment],
                depthStencilAttachment: depthAttachment
            };

            const renderPassDesc2 = {
                colorAttachments: [colorAttachment2]
            };

            commandEncoder = device.createCommandEncoder();
            if (projectionMatrixUniformBufferUpdate) {
                commandEncoder.copyBufferToBuffer(projectionMatrixUniformBufferUpdate, 0,
                    projectionMatrixUniformBuffer, 0, projectionMatrix.byteLength);
            }
            commandEncoder.copyBufferToBuffer(lightModelViewMatrixUniformBufferUpdate, 0,
                lightModelViewMatrixUniformBuffer, 0, lightModelViewMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(modelViewMatrixUniformBufferUpdate, 0,
                modelViewMatrixUniformBuffer, 0, modelViewMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(normalMatrixUniformBufferUpdate, 0,
                normalMatrixUniformBuffer, 0, normalMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(viewDirectionUniformBufferUpdate, 0,
                viewDirectionUniformBuffer, 0, viewDir.byteLength);
            commandEncoder.copyBufferToBuffer(lightDirectionUniformBufferUpdate, 0,
                lightDirectionUniformBuffer, 0, lightDir.byteLength);

            const lightPassEncoder = commandEncoder.beginRenderPass(lightRenderPassDesc);
            lightPassEncoder.setViewport(0, 0, 1024, 1024, 0, 1);
            runCube.encodeForLight(lightPassEncoder);
            lightPassEncoder.end();
            commandEncoder.copyTextureToBuffer({ texture: lightDepthTexture, origin: { x: 0, y: 0 } }, { buffer: copiedBuffer, bytesPerRow: 1024 * 4 }, { width: 1024, height: 1024 });
            //device.queue.submit([commandEncoder.finish()]);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
            passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            runCube.encode(passEncoder);
            plane.encode(passEncoder);
            //arrow.encode(passEncoder);
            //dot.encode(passEncoder);
            spotlight.encode(passEncoder);
            passEncoder.end();

            /*passEncoder2 = commandEncoder.beginRenderPass(renderPassDesc2);
            axis.encode(passEncoder2);
            passEncoder2.end();*/
            device.queue.submit([commandEncoder.finish()]);


            await device.queue.onSubmittedWorkDone();

            if (!hasDumped) {
                hasDumped = true;
                await copiedBuffer.mapAsync(GPUMapMode.READ, 0, 1024 * 1024 * 4);

                const d = new Float32Array(copiedBuffer.getMappedRange());
                const x = new Uint8ClampedArray(1024 * 1024 * 4);
                let maxv = -900;
                let minv = 900;
                for (let i = 0; i < 1024 * 1024; ++i) {
                    const v = d[i];

                    if (maxv < v) {
                        maxv = v;
                    }
                    if (minv > v) {
                        minv = v;
                    }
                    x[i * 4] = v * 255.0;
                    x[i * 4 + 1] = v * 255.0;
                    x[i * 4 + 2] = v * 255.0;
                    x[i * 4 + 3] = v * 255.0;
                }
                copiedBuffer.unmap();
                const imageData = new ImageData(x, 1024, 1024);
                imagedataToImage(imageData);
                console.log("max min: ", maxv, minv);
            }
            if (projectionMatrixUniformBufferUpdate) {
                projectionMatrixUniformBufferUpdate.destroy();
            }
            modelViewMatrixUniformBufferUpdate.destroy();
            normalMatrixUniformBufferUpdate.destroy();
            viewDirectionUniformBufferUpdate.destroy();
            lightDirectionUniformBufferUpdate.destroy();
            lightModelViewMatrixUniformBufferUpdate.destroy();
            angle += 0.01;
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        let prevX = 0.0;
        let prevY = 0.0;
        let isDragging = false;
        const yawPitch = 1;
        const roll = 2;

        canvas.onmousedown = (event) => {
            var rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const width = rect.right - rect.left;
            const height = rect.bottom - rect.top;

            let radius = width;

            if (height < radius) {
                radius = height;
            }

            radius *= 0.5;

            const originX = width * 0.5;
            const originY = height * 0.5;

            prevX = (x - originX) / radius;
            prevY = (originY - y) / radius;

            if ((prevX * prevX + prevY * prevY) < 0.64) {
                isDragging = yawPitch;
            }
            else {
                isDragging = roll;
            }

        }

        canvas.onmousemove = (event) => {
            if (isDragging != 0) {
                var rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const width = rect.right - rect.left;
                const height = rect.bottom - rect.top;

                let radius = width;

                if (height < radius) {
                    radius = height;
                }

                radius *= 0.5;

                const originX = width * 0.5;
                const originY = height * 0.5;

                currX = (x - originX) / radius;
                currY = (originY - y) / radius;

                if (isDragging == yawPitch) {
                    arcball.yawPitch(prevX, prevY, currX, currY);
                }
                else if (isDragging == roll) {
                    arcball.roll(prevX, prevY, currX, currY);
                }
                prevX = currX;
                prevY = currY;
                //requestAnimationFrame(render);
            }
        }

        canvas.onmouseup = (event) => {
            isDragging = 0;
        }
    }

    webgpu();
</script>

</html>