<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/WebGPUUnleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/Introduction/the_gpu_driver.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/Introduction/the_gpu_driver.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >0.0 The GPU Driver</h2><p>After graduating from school, I landed my first job as a system software engineer working on OpenGL, a GPU driver. However, my understanding of driver programs was quite limited at the time. In college, GPU and driver software were not a focus of computer science studies, so all I knew was that a driver is a piece of software that acts as a bridge between hardware and applications. I had no idea how it worked or what kind of data it transferred to the hardware. It wasn't until I joined the team and started working on the project that I gained a deeper understanding of how GPU drivers operate and their crucial role in the graphics rendering process.</p><p>As graphics engineers, we write programs to draw pixels on screens. Although drawing may seem instantaneous, there is a lot of activity happening behind the scenes. To properly understand and utilize the WebGPU API, it is important to have a basic understanding of how GPU drivers and the rendering pipeline work. GPU drivers act as intermediaries between graphics applications, such as video games, the operating system, and the GPU hardware. Knowing the role of GPU drivers and the rendering pipeline helps us better understand and utilize the graphics APIs designed to control GPU hardware.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_gpudriverblackbox.jpg" original_src="gpudriverblackbox.jpg" alt="GPU Drivers Function as a Black Box That Produces Pixels" sources='[]' /><div class="img-title">GPU Drivers Function as a Black Box That Produces Pixels</div></div></p><p>A GPU driver is not a single program but rather a package of several programs that serve different functions. Some handle video compression and decompression, while others perform general computing tasks. However, the core function of a GPU driver is to enable real-time 3D graphics rendering.</p><p>It may be confusing that these GPU drivers are sometimes also referred to as graphics specifications. This is because behind the implementations, there are API specifications that have been agreed upon by many companies. For example, the DirectX standard, which is the API of choice for the majority of games on Windows platforms, is led by Microsoft. OpenGL, on the other hand, is defined by the Khronos Group, a consortium of representatives from major companies involved in 3D graphics. The implementations of these APIs are typically the responsibility of GPU vendors such as NVIDIA, AMD, and Intel, and are released and installed on our computers in the form of drivers.</p><p>For many years, OpenGL and DirectX were the primary choices for real-time 3D graphics. However, in recent years, new APIs such as Vulkan, DirectX 12 on PC, and Metal on Mac have emerged. DirectX 12, although it feels like a successor to the DirectX family, is a completely new design that has diverged significantly from DirectX 11, making it a distinct API.</p><p>The emergence of new graphics standards reflects a shift in the mindset of API design. Older generation APIs strived to be generic and provide heavy lifting for all use cases, but as a result, they became slow and cumbersome. In contrast, newer APIs are designed to be lightweight and put more responsibility on developers for fine-tuning and performance optimization. While this makes graphics development using new APIs more challenging, it also allows for greater control and improved performance. Development efficiency and ergonomics are now supported by high-level graphics middleware, such as game engines, that can help with specific use cases. For instance, if you are developing a video game, it is generally not recommended to start from scratch using a low-level API, but rather to choose a suitable game engine.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_webapi.jpg" original_src="webapi.jpg" alt="Web 3D APIs Are Wrappers Built on Top of Native Drivers" sources='[]' /><div class="img-title">Web 3D APIs Are Wrappers Built on Top of Native Drivers</div></div></p><p>The development of 3D graphics for the web has followed a similar path to other graphics technologies. WebGL and WebGL2 were the first web 3D APIs, sharing their roots with OpenGL ES 2 and 3. They were simplified for efficiency on less capable devices and dropped the requirement for backward compatibility. Unlike other graphics APIs, these web APIs are not implemented by hardware vendors in drivers but are instead provided by web browsers. The web browser translates these APIs to one of the native APIs. For example, in Chrome, there is a subsystem called ANGLE that implements the WebGL APIs. On Windows, the implementation is realized via DirectX.</p><p>Until very recently, WebGL and WebGL2 have been the most widely used 3D graphics APIs for the web. However, WebGPU, the web counterpart of the new generation of 3D APIs that follows the same principles of lightweight design, is set to replace WebGL in the near future. As a result, now is an excellent time to start learning this new standard.</p><p>Now that we have a broad understanding of the landscape of graphics APIs, what exactly does a graphics driver do?</p><p>As we know, an operating system runs in two modes: kernel mode and user mode. Kernel mode handles the most essential functions required for the operating system to operate. In contrast, user mode is less critical, and most applications run in this mode. There is only one operating system kernel running, which serves many other applications operating in user mode.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_usermodevskernelmode.jpg" original_src="usermodevskernelmode.jpg" alt="Each Application Loads Its Own User Mode Instance, Which Instances With the Kernel Mode Driver to Communicate With the GPU." sources='[]' /><div class="img-title">Each Application Loads Its Own User Mode Instance, Which Instances With the Kernel Mode Driver to Communicate With the GPU.</div></div></p><p>When it comes to GPU drivers, the architecture is similar. Some GPU drivers run in kernel mode, where they are responsible for scheduling draw commands to the GPU hardware, allocating or sending resources, and performing synchronization between the CPU and the GPU. There is only one instance of the kernel mode GPU driver. Other components, implemented as dynamically linked libraries, run in user mode as part of an application, providing the high-level interfaces for graphics functions, with OpenGL and DirectX being the most famous ones. We will dive deeper into the architecture of GPU drivers in a later section.</p><p>Now let's look at how user mode drivers and kernel mode drivers work together with the operating system to enable the graphics subsystem to function properly.</p><p>In a running system, every application that needs to perform graphics tasks has its own instance of the user mode driver loaded. Hence, there are multiple instances of the user mode drivers. In contrast, the kernel mode driver is loaded only once at boot time and is shared by the entire system, including both user applications and system components such as the desktop.</p><p>Graphics drivers serve three important roles: First, they act as real-time compilers, translating developers' API calls into machine code that the GPU hardware can understand. Second, they serve as resource managers, allocating and releasing GPU memory as needed. Finally, they act as schedulers, sending work to the GPU and providing the necessary infrastructure for synchronization between the CPU and GPU. Let's look at each role in detail.</p><p>You may wonder why a graphics application needs a real-time compiler when a CPU program does not seem to require one. This is because:</p><ol><li><p>There are no standard instruction sets for GPU hardware, unlike on the CPU side where both x86 and ARM have open and standardized instruction sets. If a program is built for a specific CPU architecture, it should run on all CPUs of the same architecture, regardless of the hardware manufacturer. On the GPU side, however, NVIDIA's instructions are not compatible with AMD's, so the machine code must be generated based on the specific hardware in use.</p></li><li><p>The primary function of GPU hardware is rendering, but the exact rendering content cannot be determined at compile time. For example, consider an app that displays a clock. The current time determines what is displayed on the user interface, and based on this time, the CPU code generates a series of GPU drawing commands, which are then sent to the GPU for rendering. Since the GPU drawing commands are determined by the current time, they must be generated on the fly during execution.</p></li></ol><p>On the resource management side, a GPU driver is responsible for allocating resources in GPU memory. These resources can include textures, buffers containing geometry, or shader programs. Shader programs run on the GPU and are responsible for outputting pixels to the screen. Writing shader programs is a key aspect of GPU programming, and we will explore this topic in more detail in later chapters.</p><p>Because GPU memory is limited, the driver must manage it efficiently. For example, it may temporarily swap unused GPU resources into CPU memory to prioritize other resource allocations, allowing the system to run more graphics applications than the raw GPU memory would otherwise permit. Additionally, the data transfer speed between CPU and GPU memory is relatively slow, so the driver must be optimized to reduce data transfers and maximize performance.</p><p>The third role of a GPU driver is as a job scheduler and synchronization infrastructure.</p><p>All user applications send their draw commands and resource upload requests to the kernel mode driver. In this context, "uploading" refers to copying data from CPU memory to GPU memory, while the opposite process, copying data from GPU memory to CPU memory, is referred to as "downloading."</p><p>The kernel mode driver is responsible for sending these requests to the GPU hardware for execution and notifying the system when a request is complete. This process is similar to the JavaScript event loop, with each request acting like an asynchronous function call.</p><p>However, scheduling is not as simple as it may seem. Since the kernel mode driver is shared by the entire system, the workload must be managed carefully and fairly. If the GPU becomes stuck on a long-running job, it can cause the whole system to hang, much like how a long-running JavaScript function can freeze a web browser.</p><p>In addition to its other responsibilities, a GPU driver also helps with synchronization between the CPU and GPU to avoid data races. For example, if we are rendering a 3D scene and want to save the rendered result as an image, we need the driver to notify us when the rendering is complete before we save it.</p><p>As a concrete example, when a graphics application, such as a game, is launched, it requests the operating system to load the appropriate user mode driver and begins to interact with the GPU by calling the functions provided by the graphics API. The video game needs to allocate resources, such as buffers and textures, via the APIs and configure the behavior of the rendering by defining shader programs. During rendering, the game sends geometry data through the API for rendering. The user mode driver translates these function calls into low-level commands and data that the GPU hardware can understand and sends them to the kernel mode driver for job scheduling via system calls. The kernel mode driver responds to all GPU-related requests from the entire system, queues up all these requests for execution, and ensures the queuing strategy is fair and efficient for the entire system.</p><p>In summary, this section has provided an overview of the landscape of graphics APIs, the architecture of GPU drivers, and how user mode drivers, operating systems, and kernel mode drivers work together to control the GPU hardware. We have also discussed the three main roles that a GPU driver performs. However, the driver is just an assistant to the GPU, and the actual rendering is carried out by the hardware using a concept called the GPU pipeline. In the next section, we will explore this pipeline in greater detail, as it forms the basis of the design of graphics APIs.</p>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/index.html">Home</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/WebGPUUnleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }


    </script>
</body>

</html>