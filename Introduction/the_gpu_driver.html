<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/Introduction/the_gpu_driver.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/Introduction/the_gpu_driver.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />

    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    </script>
</head>

<body>
    <div id="menuToggle">
        <input type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                        <li><a href="/WebGPUUnleashed/Control/error_handling_and_limits.html">Error Handling and Limits</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >0.0 The GPU Driver</h2><p>As graphics engineers, we write programs to draw pixels on screens. Although drawing may seem instant, there is a lot of activity happening behind the scenes. In order to properly understand and utilize the WebGPU API, it is important to have a basic understanding of how GPU drivers and the rendering pipeline work. GPU drivers act as intermediaries between the operating system and the GPU hardware, translating instructions from the graphics API into commands that the GPU can understand and execute. This allows the GPU to perform complex rendering tasks efficiently and quickly. Knowing the role of GPU drivers and the rendering pipeline can help us better understand and utilize the graphics APIs that are designed to control the GPU hardware.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="JOn12W8n34NNzXIzW1iF8AEk1S7bC8lGXZ5CcvGqHRsz0JUp-xp__pk4gHkeZLf2tuWRADHuXRIjAeFpJOfeD0NkNY7RRfMaDc5dJ_iMZAuuxTeNS7uhcI7xVs08ORwqLYY1aV1oFCztM2ajpl_1oOC-MBgZ2Jcxy0S0.svg" alt="Pipeline" sources='[]' /><div class="img-title">Pipeline</div></div></p><p>After graduating from school, I landed my first job as a system software engineer working on OpenGL, a GPU driver. However, my understanding of driver programs was very limited at the time. In college, GPU and driver software were not a focus of my computer science studies, so all I knew was that a driver is a piece of software that acts as a bridge between hardware and applications. I had no idea how it worked or what kind of data it transferred to the hardware. It wasn't until I joined the team and started working on the project that I gained a deeper understanding of how GPU drivers operate and the important role they play in the graphics rendering process.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="RO_B2i9034NtynN1VJT-WFZQYIWKSL6wYDDG1wUPaabz8FwxGJUAPX6ISvDmCysAeaCNNJu5xb6mWpdwKojfu6QHOX9GGSuc4Ul7b4zTdzXOgRT8O2V67-eHkRb8K2Ms_O6SHJNh-nWyQaXS5vDgZMtmjND2Nf5REp9weH7SNRMd0ymbNJ993KKnWMfd9NIf8LXAE1jsl-WzkIbDi_JkLYHCyNlpOMx-S3Er3LUAsLnDYHjx.svg" alt="Pipeline" sources='[]' /><div class="img-title">Pipeline</div></div></p><p>A GPU driver is not a single program, but rather a package of several programs that serve different functions. Some handle video compression and decompression, while others perform general computing tasks. However, the core function of a GPU driver is to enable real-time 3D graphics rendering. In terms of architecture, some parts of a GPU driver run in kernel mode, where they are responsible for scheduling draw commands to the GPU hardware, allocating or sending resources, and performing synchronization between the CPU and the GPU. Other components run in user mode as part of an application, providing the interfaces for graphics functions. Two of the most well-known 3D graphics drivers or APIs are OpenGL and its lightweight version, OpenGL ES for embedded systems, as well as DirectX. We will dive deeper into the architecture of GPU drivers in a later section.</p><p>GPU drivers are sometimes also referred to as graphics specifications, as they are first released as standards that have been agreed upon by many companies. Afterward, GPU vendors such as NVIDIA, AMD, and Intel provide implementations of these standards as part of their driver packages. DirectX is the API of choice for the majority of games on Windows platforms, and its design is led by Microsoft. OpenGL, on the other hand, is defined by an organization called Khronos, which is a group of representatives from major companies that have products or businesses in 3D graphics. For many years, these two standards were the only choices for real-time 3D graphics. However, in recent years, we have seen the emergence of new APIs such as Vulkan, DirectX 12 on PC, and Metal on Mac. DirectX 12 is a completely new design that has departed from DirectX 11, so it is considered a new API.</p><p>The emergence of new graphics standards reflects a shift in the mindset of API design. Older generation APIs strive to be generic and provide heavy lifting for all use cases, but as a result, they have become slow and cumbersome. In contrast, newer APIs are designed to be lightweight and put more responsibility on developers for fine-tuning and better performance. While this makes graphics development using new APIs more challenging, it also allows for greater control and improved performance. Thankfully, there are high-level graphics middleware such as game engines that can help with specific use cases, allowing game developers to benefit from using these engines instead of implementing everything from scratch using low-level APIs.</p><p>The development of 3D graphics for the web has followed a similar path to other graphics technologies. WebGL and WebGL2 were the first web 3D APIs, and they share their roots with OpenGL ES 2 and 3. They were simplified for efficiency on less capable devices and dropped the requirement for backward compatibility. Unlike other graphics APIs, these web APIs are not implemented by hardware vendors in drivers but are instead provided by web browsers.</p><p>Until now, WebGL and WebGL2 have been the most widely used 3D graphics APIs for the web. However, WebGPU, the web counterpart of the new generation of 3D APIs that follows the same principles of lightweight design, is set to replace WebGL in the near future. As a result, now is an excellent time to start learning this new standard.</p><p>Now that we have a broad understanding of the landscape of graphics APIs, what exactly does a graphics driver do?</p><p>As previously mentioned, there are two types of GPU drivers: user mode drivers and kernel mode drivers. These drivers work together with the operating system to enable the graphics subsystem to function properly.</p><p>For user mode drivers, there are multiple instances of these drivers in a running system. In fact, every application that needs to perform graphics rendering has its own instance of the driver loaded as a dynamic library. In contrast, the kernel mode driver is loaded only once at boot time and is shared by the entire system, including both user applications and the desktop and other system components.</p><p>When a graphics application, such as a game, is launched, it requests the operating system to load the appropriate user mode driver and begins to interact with the GPU by calling the functions provided by the graphics API. The user mode driver translates these function calls into low-level commands and data that the GPU hardware can understand and sends them to the kernel driver for job scheduling.</p><p>The GPU driver plays three important roles in the graphics rendering process:</p><ol><li><p>It acts as a real-time compiler, translating developers' API calls into machine code that the GPU hardware can understand.</p></li><li><p>It serves as a resource manager, allocating and releasing GPU memory as needed.</p></li><li><p>It acts as a scheduler, sending work to the GPU and providing the necessary infrastructure for synchronization between the CPU and GPU.</p></li></ol><p>Let's take a closer look at the roles of a GPU driver, starting with its function as a real-time compiler.</p><p>Why does a graphics application need a real-time compiler, when a CPU program does not seem to require one? This is because:</p><ol><li><p>There are no standard instruction sets for GPU hardware, unlike on the CPU side where both X86 and ARM have open and standardized instruction sets. If a program is built for a specific CPU architecture, it should run on all CPUs of the same architecture, regardless of the hardware manufacturer. On the GPU side, however, NVIDIA's instructions are not compatible with AMD's, so the machine code must be generated based on the specific hardware in use.</p></li><li><p>The primary function of GPU hardware is rendering, but the exact rendering tasks cannot be determined at compile time. For example, consider an app that displays a clock. The current time determines what is displayed on the user interface, and based on this time, the CPU code generates a series of GPU drawing commands, which are then sent to the GPU for rendering. The generation of these commands must be dynamic.</p></li></ol><p>On the resource management side, a GPU driver is responsible for allocating resources on the GPU memory. Resources can include textures, buffers containing geometry, or shader programs. Shader programs are programs that run on the GPU and are responsible for outputting pixels on the screen. Writing shader programs is a key aspect of GPU programming, and we will explore this topic in more detail in later chapters.</p><p>Because GPU memory is limited, the driver must use it efficiently. For example, it may temporarily swap unused GPU resources into CPU memory in order to prioritize other resource allocations, allowing the system to run more graphics applications than the raw GPU memory would otherwise permit. Additionally, the data transfer speed between CPU and GPU memory is relatively slow, so the driver must be smart in reducing data transfer to maximize performance.</p><p>The third role of a GPU driver is as a job scheduler and synchronization infrastructure.</p><p>All user applications send their draw commands and resource uploading requests to the kernel mode driver. In this context, "uploading" refers to copying data from CPU memory to GPU memory, while the opposite process, copying data from GPU memory to CPU memory, is referred to as "downloading".</p><p>The kernel mode driver is responsible for sending these requests to the GPU hardware for execution and notifying the system when a request is complete. As a metaphor, this process is similar to the JavaScript event loop, with each request acting like an asynchronous function call.</p><p>However, scheduling is not as simple as it may seem. Since the kernel mode driver is shared by the entire system, the workload must be managed carefully and fairly. If the GPU becomes stuck on a long-running job, it can cause the whole system to hang, just as a long-running JavaScript function can freeze a web browser.</p><p>In addition to its other responsibilities, a GPU driver also helps with synchronization between the CPU and GPU to avoid data races. For example, if we are rendering a 3D scene and want to save the rendered result as an image, we want the driver to notify us when the rendering is complete before we save it.</p><p>In summary, this section has provided an overview of the landscape of graphics APIs, the architecture of GPU drivers, and how user mode drivers, operating systems, and kernel mode drivers work together to control the GPU hardware. We have also discussed the three main roles that a GPU driver performs. However, the driver is just an assistant to the GPU, and the actual rendering is carried out by the hardware using a concept called the GPU pipeline. In the next section, we will explore this pipeline in greater detail, as it forms the basis of the design of graphics APIs.</p>
        </article>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }


    </script>
</body>

</html>