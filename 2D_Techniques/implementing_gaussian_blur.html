<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />

    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    </script>
</head>

<body>
    <div id="menuToggle">
        <input type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                        <li><a href="/WebGPUUnleashed/Control/error_handling_and_limits.html">Error Handling and Limits</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >2.2 Implementing Gaussian Blur</h2><p>2D image processing is a great use case for WebGPU. In this tutorial, we will implement one of the most common 2D image filter - gaussian blur. A naive implementation is not difficult, but we will try to implement an optimized version in a series of 5 iterations of incremental improvements.</p><p>For 2D image processing, we typically render the image needed to be processed on a screen aligned rectangle. The general setup should be familiar to us already, hence I will not repeat it. We will instead focus on the blur algorithm implemented in the fragment shader. please refer to the sample code for detailed pipeline setup etc.</p><p>let's look at the most basic version. This version shouldn't be called gaussian blur yet, as for each pixel, it only calculate an average of the nearby colors (often called the box blur), whereas a full gaussian blur calculates a weighted average based on a gaussian kernel.</p><pre><code class="language-javascript code-block">@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    const kernelSize = 8.0;
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var y: f32 = - kernelSize; y &lt;= kernelSize; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            for (var x: f32 = -kernelSize; x&lt;=kernelSize; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    let tex_coord = vec2(offsettedX / img_size.x, offsettedY / img_size.y);

                    let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);

                    color += c;
                    intensity += 1.0;
                }
            }
        }
    }

    color /= intensity;
    color.w = 1.0;

    return color;
}</code></pre><p>The general idea of the above code is very simple, for each pixel, we look at its nearby 8x8 window. we fetch all pixels from this window and calculate the average color. recall that previously we said that the function textureSample has to be called in a uniform control flow. Here we are calling textureSampleLevel but it is not in a uniform control flow. what's the difference.</p><p>the textureSampleLevel function asks for one more parameter than the textureSample. The extra parameter is a level id. Hence, the textureSampleLevel function can't do mipmap, but require an explicit level index. It turns out that the logic in textureSample that determines the right mipmap levels is the component that requires the uniformity. If we do not need mipmapping, we don't have to sample texture in a uniform control flow.</p><p>Now let's look at an improved version:</p><pre><code class="language-javascript code-block">@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    const kernelSize = 8.0;
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;
    const sigma = 8.0;
    const PI = 3.1415926538;

    for(var y: f32 = - kernelSize; y &lt;= kernelSize; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            for (var x: f32 = -kernelSize; x&lt;=kernelSize; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    let tex_coord = vec2(offsettedX / img_size.x, offsettedY / img_size.y);
                    let gaussian_v = 1.0 / (2.0 * PI * sigma * sigma) * exp(-(x*x + y*y) / (2.0 * sigma * sigma));
                    let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
                    color += c * gaussian_v;
                    intensity += gaussian_v;
                }
            }
        }
    }

      color /= intensity;
      color.w = 1.0;

      return color;
}</code></pre><p>this version is not that different from the previous version, but we are not apply a weight for each color. The weight is based on the gaussian value given the distance of each pixel to the center pixel.</p><p>The problem of the above version is that for each fragment, we are recalculating the gaussian value. but this is not necessary, because the 8x8 window is the same for all fragments, the gaussian value of each pixel on the 8x8 window is solely determined by its distance to the center. hence the values should be the same across all fragments. we should hence calculate the gaussian weights once and cache them in a lookup table. we can retrieve the gaussian weights instead of repeating the calculation. let's modify our code as the following.</p><pre><code class="language-javascript code-block">// Fragment shader
...
@group(0) @binding(5)
var&lt;storage&gt; kernel: array&lt;f32&gt;;
@group(0) @binding(6)
var&lt;uniform&gt; kernel_size: f32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    ...
    for(var y: f32 = - kernel_size; y &lt;= kernel_size; y+=1.0) {
        ...
            for (var x: f32 = -kernel_size; x&lt;=kernel_size; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    ...
                    let gaussian_v = kernel[index];
                    ...
                }
            }
        
    }
...
}</code></pre><p>the gaussian weights are calculated by javascript and passed in as a uniform array.</p><p>The problem of the code snippet we have seen so far is that for each fragment, we have to loop 8x8 times. That's a lot of calculation, especially if we time that with the number of pixels. to further optimize it, we have to reduce the number of loop iterations.</p><p>now, if we inspect the equation for the 2D gaussian, we see that it can be separated to a multiplication. take the top row as an example, we can calculated it by first treating it as a 1D problem, and calculate the horizontal weighted sum. and then we multiply exp(-y). The same can be applied to all rows. Hence we can break the calculation down to two passes. During the first pass, we calculate the 1D gaussian blur horizontally, and during the second pass, we do it again vertically. the end result is the same as calculating it in a 8x8 window.</p><p>the benefit of this approach is that we eliminated a lot of loops. Because to calculate the horizontal 1D gaussian, we only need to loop for 3 times, plus the 3 times for vertical, we only need to loop for 6 times in total, vs the 64 times previously, this is a huge saving.</p><p>but this has to be carried out in two passes with two shaders:</p><pre><code class="language-javascript code-block">    @group(0) @binding(2)
    var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
    @group(0) @binding(3)
    var v_result: texture_2d&lt;f32&gt;;
    @group(0) @binding(4)
    var s_diffuse: sampler;
    @group(0) @binding(5)
    var&lt;storage&gt; kernel: array&lt;f32&gt;;
    @group(0) @binding(6)
    var&lt;uniform&gt; kernel_size: f32;

    @fragment
    fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    
        var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
        var intensity: f32 = 0.0;
    
        for(var x: f32 = - kernel_size; x &lt;= kernel_size; x+=1.0) {
            let offsettedX = x + in.pixel_coord.x;
            if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x ) {
                let indexX = u32(x + kernel_size);
                let tex_coord = vec2(offsettedX / img_size.x, in.pixel_coord.y / img_size.y);
                
                let gaussian_v = kernel[indexX];
                let c = textureSampleLevel(v_result, s_diffuse, tex_coord,0);
                color += c * gaussian_v;
                intensity += gaussian_v;
            }
        }

        color /= intensity;
        color.w = 1.0;
    
        return color;
    }</code></pre><p>and vertical:</p><pre><code class="language-javascript code-block">// Fragment shader
@group(0) @binding(0)
var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
//texture doesn't need &lt;uniform&gt;, because it is non-host-sharable (what does it mean?)
@group(0) @binding(1)
var t_diffuse: texture_2d&lt;f32&gt;;
@group(0) @binding(2)
var s_diffuse: sampler;
@group(0) @binding(3)
var&lt;storage&gt; kernel: array&lt;f32&gt;;
@group(0) @binding(4)
var&lt;uniform&gt; kernel_size: f32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {[text](https://indiehackers.social/)
    
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var y: f32 = - kernel_size; y &lt;= kernel_size; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            let indexY = u32(y + kernel_size);
            let tex_coord = vec2(in.pixel_coord.x / img_size.x, offsettedY / img_size.y);
            let gaussian_v = kernel[indexY];
            let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
            color += c * gaussian_v;
            intensity += gaussian_v;
        }
    }

    color /= intensity;
    color.w = 1.0;

    return color;
}</code></pre><p>We need to create 2 pipelines for these shaders and launch them in consecutively.</p>
        </article>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
</body>

</html>