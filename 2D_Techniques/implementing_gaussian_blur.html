<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/WebGPUUnleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                        <li><a href="/WebGPUUnleashed/Control/error_handling_and_limits.html">Error Handling and Limits</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >2.2 Implementing Gaussian Blur</h2><p>2D image processing is a great use case for WebGPU. In this tutorial, we will implement one of the most common 2D image filter - gaussian blur. A naive implementation is not difficult, but we will try to implement an optimized version in a series of 5 iterations of incremental improvements.</p><p>For 2D image processing, we typically render the image needed to be processed on a screen aligned rectangle. The general setup should be familiar to us already, hence I will not repeat it. We will instead focus on the blur algorithm implemented in the fragment shader. please refer to the sample code for detailed pipeline setup etc.</p><p>let's look at the most basic version. This version shouldn't be called gaussian blur yet, as for each pixel, it only calculate an average of the nearby colors (often called the box blur), whereas a full gaussian blur calculates a weighted average based on a gaussian kernel.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#2_02_1_blur_1" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 2_02_1_blur_1</a><p>Since the javascript setup is quite similar to the texture mapping tutorial and many other previous samples, I will skip repeatedly showing you what we have known. the focus of this tutorial is mainly on the fragment shader, as that's where the algorithm is mainly implemented.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=42>@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    const kernelSize = 8.0;
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var y: f32 = - kernelSize; y &lt;= kernelSize; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            for (var x: f32 = -kernelSize; x&lt;=kernelSize; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    let tex_coord = vec2(offsettedX / img_size.x, offsettedY / img_size.y);
                    let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
                    color += c;
                    intensity += 1.0;
                }
            }
        }
    }
      
      color /= intensity;
      color.w = 1.0;

      return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=41:66#2_02_1_blur_1">2_02_1_blur_1/index.html:42-67 Naive Implementation of Box Blur Using Nested for Loops</a></div></div><p>The general idea of the above code is very simple, for each pixel, we look at its nearby 15x15 window. we fetch all pixels from this window and calculate the average color. recall that previously we said that the function <code>textureSample</code> has to be called in a uniform control flow. Here we are calling a slight different variant of it, called <code>textureSampleLevel</code> but it is not in a uniform control flow. what's the difference?</p><p>the <code>textureSampleLevel</code> function asks for one more parameter than <code>textureSample</code>. The extra parameter is a level id. Hence, the <code>textureSampleLevel</code> function can't do mipmap, but require an explicit level index. It turns out that the logic in <code>textureSample</code> that determines the right mipmap levels is the component that requires the uniformity. If we do not need mipmapping, we don't have to sample texture in a uniform control flow. we will explain why determining the right mipmap level requires uniformity in a future chapter.</p><p>Now let's look at an improved version:</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#2_02_2_blur_2" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 2_02_2_blur_2</a><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=41>@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    const kernelSize = 8.0;
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;
    const sigma = 8.0;
    const PI = 3.1415926538;

    for(var y: f32 = - kernelSize; y &lt;= kernelSize; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            for (var x: f32 = -kernelSize; x&lt;=kernelSize; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    let tex_coord = vec2(offsettedX / img_size.x, offsettedY / img_size.y);
                    let gaussian_v = 1.0 / (2.0 * PI * sigma * sigma) * exp(-(x*x + y*y) / (2.0 * sigma * sigma));
                    let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
                    color += c * gaussian_v;
                    intensity += gaussian_v;
                }
            }
        }
    }
      
      color /= intensity;
      color.w = 1.0;

      return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=40:68#2_02_2_blur_2">2_02_2_blur_2/index.html:41-69 Naive Implementation of Gaussian Blur Using Nested for Loops</a></div></div><p>this version is not that different from the previous version, but we are now applying a weight for each color. The weight is based on the gaussian value given the distance of each pixel to the center pixel, such that closer texels will contribute more to the final color than those are further away.</p><p>recall the equation of a 2D gaussian:</p><p class="katex-display-counter"><code class="language-math math-block">G(x,y) = \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}</code></p><p>The problem of the above version is that for each fragment, we are recalculating the gaussian values. but this is not necessary, because the 15x15 window is the same for all fragments, the gaussian values of each pixel on the 15x15 window is solely determined by the distances to the center. hence the values should be the same across all fragments. we should hence calculate the gaussian weights once and cache them in a lookup table. we can retrieve the gaussian weights instead of repeating the calculation. let's modify our code as the following.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=33>@group(0) @binding(2)
var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
//texture doesn't need &lt;uniform&gt;, because it is non-host-sharable (what does it mean?)
@group(0) @binding(3)
var t_diffuse: texture_2d&lt;f32&gt;;
@group(0) @binding(4)
var s_diffuse: sampler;
@group(0) @binding(5)
var&lt;storage&gt; kernel: array&lt;f32&gt;;
@group(0) @binding(6)
var&lt;uniform&gt; kernel_size: f32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var y: f32 = - kernel_size; y &lt;= kernel_size; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            for (var x: f32 = -kernel_size; x&lt;=kernel_size; x+=1.0) {
                let offsettedX = x + in.pixel_coord.x;
                if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x) {
                    let indexY = u32(y + kernel_size);
                    let indexX = u32(x + kernel_size);
                    let index = indexY * (u32(kernel_size) * 2 + 1) + indexX;

                    let tex_coord = vec2(offsettedX / img_size.x, offsettedY / img_size.y);
                    let gaussian_v = kernel[index];
                    let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
                    color += c * gaussian_v;
                    intensity += gaussian_v;
                }
            }
        }
    }
      

      color /= intensity;
      color.w = 1.0;

      return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=32:74#2_02_3_blur_3">2_02_3_blur_3/index.html:33-75 Improved Gaussian Blur Using a Lookup Table</a></div></div><p>the gaussian weights are calculated by javascript and passed in as a storage array. this is the first time we have seen a storage array. the reason we want to use a storage array. The reason we are using the storage buffer here is because the size of the weight array is related to the window size. We want it to be flexible, so that we can adjust the window size. As a result, the array size can't be predetermined. runtime-sized arrays can only be used in the storage address space, not in the uniform address space, therefore we want to use the storage buffer here. Storage buffer offers other benefits too, such as supporting write back values from a shader. we will look at more storage buffer usages in the future.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=161>let kValues = []

const kernelSize = 8.0;
const sigma = 8.0;
let intensity = 0.0;

for (let y = - kernelSize; y &lt;= kernelSize; y += 1.0) {
    for (let x = -kernelSize; x &lt;= kernelSize; x += 1.0) {
        let gaussian_v = 1.0 / (2.0 * Math.PI * sigma * sigma) * Math.exp(-(x * x + y * y) / (2.0 * sigma * sigma));
        intensity += gaussian_v;
        kValues.push(gaussian_v);
    }
}

const kernelBuffer = new Float32Array(kValues);

const kernelBufferStorageBuffer  = createGPUBuffer(device, kernelBuffer, GPUBufferUsage.STORAGE);

const kernelSizeBuffer = new Float32Array([kernelSize]);

const kernelBufferSizeUniformBuffer = createGPUBuffer(device, kernelSizeBuffer, GPUBufferUsage.UNIFORM);
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=191>let uniformBindGroupLayout = device.createBindGroupLayout({
    entries: [
        {
            binding: 0,
            visibility: GPUShaderStage.VERTEX,
            buffer: {}
        },
        {
            binding: 1,
            visibility: GPUShaderStage.VERTEX,
            buffer: {}
        },
        {
            binding: 2,
            visibility: GPUShaderStage.FRAGMENT,
            buffer: {}
        },
        {
            binding: 3,
            visibility: GPUShaderStage.FRAGMENT,
            texture: {}
        },
        {
            binding: 4,
            visibility: GPUShaderStage.FRAGMENT,
            sampler: {}
        },
        {
            binding: 5,
            visibility: GPUShaderStage.FRAGMENT,
            buffer: {
                type: 'read-only-storage'
            }
        },
        {
            binding: 6,
            visibility: GPUShaderStage.FRAGMENT,
            buffer: {}
        }
    ]
});

let uniformBindGroup = device.createBindGroup({
    layout: uniformBindGroupLayout,
    entries: [
        {
            binding: 0,
            resource: {
                buffer: translateMatrixUniformBuffer
            }
        },
        {
            binding: 1,
            resource: {
                buffer: projectionMatrixUniformBuffer
            }
        },
        {
            binding: 2,
            resource: {
                buffer: imgSizeUniformBuffer
            }
        },
        {
            binding: 3,
            resource: texture.createView()
        },
        {
            binding: 4,
            resource:
                sampler
        },
        {
            binding: 5,
            resource: {
                buffer: kernelBufferStorageBuffer
            }
        },
        {
            binding: 6,
            resource: {
                buffer: kernelBufferSizeUniformBuffer
            }
        }
    ]
});
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=160:180,190:275#2_02_3_blur_3">2_02_3_blur_3/index.html:161-276 Setting Up Gaussian Kernels in Javascript</a></div></div><p>the above code snippet shows how we populate the kernel data in javascript. notice that the usage is set to <code>STORAGE</code> to match the <code>storage</code> address space specified in the shader. And when defining the <code>uniformBindGroupLayout</code>, we need to specify <code>type: 'read-only-storage'</code>. The 2D gaussian kernel is unrolled into a 1D array. Inside the shader, we recover the 1D access index from the xy coordinates. <code>kernelSize</code> defines the window size <code>windowSize = 2 * kernelSize + 1</code>.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#2_02_3_blur_3" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 2_02_3_blur_3</a><p>The problem of the code snippet we have seen so far is that for each fragment, we have to loop 15x15 times. That's a lot of calculation, especially if we time that with the number of pixels. to further optimize it, we have to reduce the number of loop iterations.</p><p class="katex-display-counter"><code class="language-math math-block">\begin{aligned}
G(x,y) &= \frac{1}{2\pi\sigma^2}e^{-\frac{x^2+y^2}{2\sigma^2}}
G(x,y) &= \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}\times \frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{y^2}{2\sigma^2}}
\end{aligned}</code></p><p>now, if we inspect the equation for the 2D gaussian, we see that it can be separated to a multiplication. take the left column of the gaussian kernel as an example, we can calculated it by first treating it as a 1D gaussian, and calculate the vertical weighted sum for each texel. and then we multiply it by the horizontal gaussian: <code class="language-math math-inline">\frac{1}{\sqrt{2\pi\sigma^2}}e^{-\frac{x^2}{2\sigma^2}}</code>. Hence we can break the calculation down to two passes. During the first pass, we calculate the 1D gaussian blur vertically, and during the second pass, we do it again horizontally. the end result is the same as calculating it in a 15x15 window.</p><p>the benefit of this approach is that we eliminated a lot of loops. Because to calculate the vertical 1D gaussian, we only need to loop for 15 times, plus the 15 times for horizontal, we only need to loop for 30 times in total, vs the 15x15 times previously, this is a huge saving.</p><p>but this has to be carried out in two passes with two shaders:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=33>@group(0) @binding(0)
var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
//texture doesn't need &lt;uniform&gt;, because it is non-host-sharable (what does it mean?)
@group(0) @binding(1)
var t_diffuse: texture_2d&lt;f32&gt;;
@group(0) @binding(2)
var s_diffuse: sampler;
@group(0) @binding(3)
var&lt;storage&gt; kernel: array&lt;f32&gt;;
@group(0) @binding(4)
var&lt;uniform&gt; kernel_size: f32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var y: f32 = - kernel_size; y &lt;= kernel_size; y+=1.0) {
        let offsettedY = y + in.pixel_coord.y;
        if (offsettedY &gt;= 0.0 &amp;&amp; offsettedY &lt;= img_size.y ) {
            let indexY = u32(y + kernel_size);
            let tex_coord = vec2(in.pixel_coord.x / img_size.x, offsettedY / img_size.y);
            let gaussian_v = kernel[indexY];
            let c = textureSampleLevel(t_diffuse, s_diffuse, tex_coord,0);
            color += c * gaussian_v;
            intensity += gaussian_v;
        }
    }

    color /= intensity;
    color.w = 1.0;

    return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=32:66#2_02_4_blur_4">2_02_4_blur_4/index.html:33-67 First Pass Calculates the Vertical Gaussian</a></div></div><p>and horizontal:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=95>@group(0) @binding(2)
var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
@group(0) @binding(3)
var v_result: texture_2d&lt;f32&gt;;
@group(0) @binding(4)
var s_diffuse: sampler;
@group(0) @binding(5)
var&lt;storage&gt; kernel: array&lt;f32&gt;;
@group(0) @binding(6)
var&lt;uniform&gt; kernel_size: f32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {

    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);
    var intensity: f32 = 0.0;

    for(var x: f32 = - kernel_size; x &lt;= kernel_size; x+=1.0) {
        let offsettedX = x + in.pixel_coord.x;
        if (offsettedX &gt;= 0.0 &amp;&amp; offsettedX &lt;= img_size.x ) {
            let indexX = u32(x + kernel_size);
            let tex_coord = vec2(offsettedX / img_size.x, in.pixel_coord.y / img_size.y);
            
            let gaussian_v = kernel[indexX];
            let c = textureSampleLevel(v_result, s_diffuse, tex_coord,0);
            color += c * gaussian_v;
            intensity += gaussian_v;
        }
    }

    color /= intensity;
    color.w = 1.0;

    return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=94:128#2_02_4_blur_4">2_02_4_blur_4/index.html:95-129 Second Pass Calculates the Horizontal Gaussian</a></div></div><p>The kernel passed into the shader is also slightly different:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=244>let kValues = []

const kernelSize = 8.0;
const sigma = 8.0;
let intensity = 0.0;

for (let y = - kernelSize; y &lt;= kernelSize; y += 1.0) {
    let gaussian_v = 1.0 / Math.sqrt(2.0 * Math.PI * sigma * sigma) * Math.exp(-(y * y) / (2.0 * sigma * sigma));
    intensity += gaussian_v;
    kValues.push(gaussian_v);
}

const kernelBuffer = new Float32Array(kValues);

const kernelBufferStorageBuffer  = createGPUBuffer(device, kernelBuffer, GPUBufferUsage.STORAGE);

const kernelSizeBuffer = new Float32Array([kernelSize]);

const kernelBufferSizeUniformBuffer = createGPUBuffer(device, kernelSizeBuffer, GPUBufferUsage.UNIFORM);
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=243:261#2_02_4_blur_4">2_02_4_blur_4/index.html:244-262 1D Gaussian Kernel Buffer</a></div></div><p>We need to create 2 pipelines for these shaders and launch them in consecutively. the first pass only calculates the vertical results and caches the them on a temporary texture map. The second pass build on top of the first pass' results to get the final output.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=337>const pipelineLayoutDescPass1 = { bindGroupLayouts: [uniformBindGroupLayoutPass1] };
const pipelineLayoutPass1 = device.createPipelineLayout(pipelineLayoutDescPass1);

const colorStatePass1 = {
    format: 'rgba8unorm'
};

const pipelineDescPass1 = {
    layout: pipelineLayoutPass1,
    vertex: {
        module: shaderModuleVertical,
        entryPoint: 'vs_main',
        buffers: [pixelCoordsBufferLayoutDescPass1]
    },
    fragment: {
        module: shaderModuleVertical,
        entryPoint: 'fs_main',
        targets: [colorStatePass1]
    },
    primitive: {
        topology: 'triangle-strip',
        frontFace: 'ccw',
        cullMode: 'none'
    }
};

const pipelinePass1 = device.createRenderPipeline(pipelineDescPass1);

let colorAttachmentPass1 = {
    view: pass1texture.createView(),
    clearValue: { r: 0, g: 0, b: 0, a: 0 },
    loadOp: 'clear',
    storeOp: 'store'
};

const renderPassDescPass1 = {
    colorAttachments: [colorAttachmentPass1]
};
commandEncoder = device.createCommandEncoder();

passEncoder = commandEncoder.beginRenderPass(renderPassDescPass1);
passEncoder.setViewport(0, 0, texture.width, texture.height, 0, 1);
passEncoder.setPipeline(pipelinePass1);
passEncoder.setBindGroup(0, uniformBindGroupPass1);
passEncoder.setVertexBuffer(0, pixelCoordsBuffer);
passEncoder.draw(4, 1);
passEncoder.end();
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=426>let uniformBindGroupPass2 = device.createBindGroup({
    layout: uniformBindGroupLayoutPass2,
    entries: [
        {
            binding: 0,
            resource: {
                buffer: translateMatrixUniformBuffer
            }
        },
        {
            binding: 1,
            resource: {
                buffer: projectionMatrixUniformBuffer
            }
        },
        {
            binding: 2,
            resource: {
                buffer: imgSizeUniformBuffer
            }
        },
        {
            binding: 3,
            resource: pass1texture.createView()
        },
        {
            binding: 4,
            resource:
                sampler
        },
        {
            binding: 5,
            resource: {
                buffer: kernelBufferStorageBuffer
            }
        },
        {
            binding: 6,
            resource: {
                buffer: kernelBufferSizeUniformBuffer
            }
        }
    ]
});

const pipelineLayoutDescPass2 = { bindGroupLayouts: [uniformBindGroupLayoutPass2] };
const pipelineLayoutPass2 = device.createPipelineLayout(pipelineLayoutDescPass2);

const colorStatePass2 = {
    format: 'bgra8unorm'
};

const pipelineDescPass2 = {
    layout: pipelineLayoutPass2,
    vertex: {
        module: shaderModuleHorizontal,
        entryPoint: 'vs_main',
        buffers: [positionBufferLayoutDesc, pixelCoordsBufferLayoutDescPass2]
    },
    fragment: {
        module: shaderModuleHorizontal,
        entryPoint: 'fs_main',
        targets: [colorStatePass2]
    },
    primitive: {
        topology: 'triangle-strip',
        frontFace: 'ccw',
        cullMode: 'none'
    }
};

const pipelinePass2 = device.createRenderPipeline(pipelineDescPass2);

let pass2texture = context.getCurrentTexture();

let colorAttachmentPass2 = {
    view: pass2texture.createView(),
    clearValue: { r: 1.0, g: 0.0, b: 0.0, a: 1.0 },
    loadOp: 'clear',
    storeOp: 'store'
}

const renderPassDescPass2 = {
    colorAttachments: [colorAttachmentPass2]
}

let passEncoder2 = commandEncoder.beginRenderPass(renderPassDescPass2);
passEncoder2.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
passEncoder2.setPipeline(pipelinePass2);
passEncoder2.setBindGroup(0, uniformBindGroupPass2);
passEncoder2.setVertexBuffer(0, positionBuffer);
passEncoder2.setVertexBuffer(1, pixelCoordsBuffer);
passEncoder2.draw(4, 1);
passEncoder2.end();


device.queue.submit([commandEncoder.finish()]);
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=336:382,425:521#2_02_4_blur_4">2_02_4_blur_4/index.html:337-522 Setting Up 2 Rendering Passes</a></div></div><p>the exact process of creating and launching two passes is exactly the same as the the render to texture tutorial has showed.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#2_02_4_blur_4" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 2_02_4_blur_4</a><p>this is not the end of the game though, there is one more opportunity we can improve the performance of gaussian blur harnessing the bilinear interpolation built into texture map access. if we model texture as simply a 2D array, accessing each texel would require one texture read. But a texture map is not the same as a 2D array, because we are allowed to sample it by using a non-whole coordinates. in this situation, bilinear interpolation is involved. we will end up having a weighted average of the two nearby pixels. if our goal, for example, to get the sum of two nearby texels, we using one texture read to get the average of the two values, by setting our texture read coordinates in the middle of them.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="bilinearinterpolation.png" alt="Reducing Texture Read by Leveraging Interpolation" sources='[]' /><div class="img-title">Reducing Texture Read by Leveraging Interpolation</div></div></p><p>we even smarter, we can incorporate the gaussian weight values into the formula. For example, in the above picture, we have a 1D texture map of 9 texels. Each green dot is a texel. if this is a 1D array, we would have access it for 9 times to get all its values, but if this is a texture map, we can leverage the built-in interpolations to access two texels at a time. in total, we only need 5 accesses to get the job done.</p><p>The first step is grouping nearby texels into sets of two. Assuming the color values of these texels are <code class="language-math math-inline">A, B ... I</code>, and their gaussian weights are <code class="language-math math-inline">a,b, ..., i</code>, therefore, eventually what we want to get is:</p><p class="katex-display-counter"><code class="language-math math-block">\frac{aA + bB + ... +iI}{a + b + ... + i}</code></p><p>Now, let's focus on <code class="language-math math-inline">A</code> and <code class="language-math math-inline">B</code>. if we set the texture coordinate to <code class="language-math math-inline">\frac{b}{a+b}</code>, we can get the following value sampled:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{aligned}
v &= \frac{a}{a+b} \times A + (1 - \frac{b}{a+b}) \times B
v &= \frac{aA+bB}{a+b}
\end{aligned}</code></p><p>since What we want is <code class="language-math math-inline">aA + bB</code>, hence we just need to scale it back by <code class="language-math math-inline">a+b</code>. We repeat this for all the two-texel groups, and in the end, we divide the weighted sum by the sum of all gaussian weights, we will essential have the same result as accessing the texture 9 times.</p><p>The above process is implemented by the following changes:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=228>let kValues = [];
let offsets = [];

const kernelSize = 8.0;
const sigma = 8.0;
let intensity = 0.0;

for (let y = - kernelSize; y &lt;= kernelSize; y += 1.0) {
    let gaussian_v = 1.0 / Math.sqrt(2.0 * Math.PI * sigma * sigma) * Math.exp(-(y * y) / (2.0 * sigma * sigma));
    intensity += gaussian_v;
    kValues.push(gaussian_v);
    offsets.push(y);
}

let kValues2 = [];
let offsets2 = [];
let i = 0;
// loop for all 2-texel groups
for (; i &lt; kValues.length - 1; i += 2) {
    const A = kValues[i];
    const B = kValues[i + 1];
    const k = A + B;
    const alpha = A / k;
    const offset = offsets[i] + alpha;
    kValues2.push(k / intensity);
    offsets2.push(offset);
}
// if the window size is an odd number, there should be one lingering texel left
if (i &lt; kValues.length) {
    const A = kValues[i];
    const offset = offsets[i];
    kValues2.push(A / intensity);
    offsets2.push(offset);
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=227:260#2_02_5_blur_5">2_02_5_blur_5/index.html:228-261 Populate the Smarter Texture Access Offset and Scale-Back Weights</a></div></div><p>And in the shader, we introduced two lookups, one for the texture accessing offsets (coordinates) to give us the right mix of two nearby texels. And a scale-back factor:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=88>@group(0) @binding(2)
var&lt;uniform&gt; img_size: vec2&lt;f32&gt;;
@group(0) @binding(3)
var v_result: texture_2d&lt;f32&gt;;
@group(0) @binding(4)
var s_diffuse: sampler;
@group(0) @binding(5)
var&lt;storage&gt; weights: array&lt;f32&gt;;
@group(0) @binding(6)
var&lt;storage&gt; offsets: array&lt;f32&gt;;
@group(0) @binding(7)
var&lt;uniform&gt; kernel_size: u32;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {    
    var color = vec4&lt;f32&gt;(0.0, 0.0, 0.0, 0.0);

    for(var x: u32 = 0; x &lt; kernel_size; x++) {
        let offsettedX = offsets[x] + in.pixel_coord.x;
            let tex_coord = vec2(offsettedX / img_size.x, in.pixel_coord.y / img_size.y);
            // access texture in middle of two samples
            let c = textureSampleLevel(v_result, s_diffuse, tex_coord,0);
            // scales back by weight
            color += c * weights[x];
    }
    color.w = 1.0;
    return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=87:114#2_02_5_blur_5">2_02_5_blur_5/index.html:88-115 Fragment Shader Implements Smarter Texture Access</a></div></div><p>The end result is the same, but way faster.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#2_02_5_blur_5" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 2_02_5_blur_5</a>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/WebGPUUnleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
</body>

</html>