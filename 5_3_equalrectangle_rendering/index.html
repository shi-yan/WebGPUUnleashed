<html>

<body style="margin: 0px; position: relative;">
    <canvas id="canvas" width="640" height="480" style="width:100%;height:100%"></canvas>
</body>
<script src="../utils/gl-matrix.js">
    //https://www.hdri-hub.com/hdrishop/freesamples/freehdri/item/113-hdr-111-parking-space-free
    //https://www.oreilly.com/library/view/webgl-programming-guide/9780133364903/appe.html
</script>
<script src="../utils/OBJFile.js"> </script>
<script src="../utils/utils.js"></script>
<script id="object_with_shadow_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    @group(0) @binding(2)
    var<uniform> normalMatrix: mat4x4<f32>;
    @group(0) @binding(3) 
    var<uniform> lightDirection: vec3<f32>;
    @group(0) @binding(4)
    var<uniform> viewDirection: vec3<f32>;
    
    @group(0) @binding(5)
    var<uniform> ambientColor:vec4<f32>;// = vec4<f32>(0.15, 0.10, 0.10, 1.0);
    @group(0) @binding(6)
    var<uniform> diffuseColor:vec4<f32>;// = vec4<f32>(0.55, 0.55, 0.55, 1.0);
    @group(0) @binding(7)
    var<uniform> specularColor:vec4<f32>;// = vec4<f32>(1.0, 1.0, 1.0, 1.0);
    
    @group(0) @binding(8)
    var<uniform> shininess:f32;// = 20.0;
        
    const diffuseReflectionConstant:f32 = 1.0;
    const specularReflectionConstant:f32 = 1.0;
    const ambientReflectionConstant: f32 = 1.0;
    
    fn specular(lightDir:vec3<f32>, viewDir:vec3<f32>, normal:vec3<f32>,  specularColor:vec3<f32>, 
         shininess:f32) -> vec3<f32> {
        let reflectDir:vec3<f32> = reflect(-lightDir, normal);
        let specDot:f32 = max(dot(reflectDir, viewDir), 0.0);
        return pow(specDot, shininess) * specularColor;
    }
    
    fn diffuse(lightDir:vec3<f32>, normal:vec3<f32>,  diffuseColor:vec3<f32>) -> vec3<f32>{
        return max(dot(lightDir, normal), 0.0) * diffuseColor;
    }
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) viewDir: vec3<f32>,
        @location(1) normal: vec3<f32>,
        @location(2) lightDir: vec3<f32>,
        @location(3) wldLoc: vec3<f32>,
        @location(4) lightLoc: vec3<f32>,
        @location(5) inPos: vec3<f32>
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>,
        @location(1) inNormal: vec3<f32>
    ) -> VertexOutput {
        var out: VertexOutput;
    
        out.viewDir = normalize((normalMatrix * vec4<f32>(-viewDirection, 0.0)).xyz);
        out.lightDir = normalize((normalMatrix * vec4<f32>(-lightDirection, 0.0)).xyz);
        out.normal = normalize(normalMatrix * vec4<f32>(inNormal, 0.0)).xyz;  
        var wldLoc:vec4<f32> = modelView * vec4<f32>(inPos, 1.0);
        out.clip_position = projection * wldLoc;
        out.wldLoc = wldLoc.xyz / wldLoc.w;
        out.inPos = inPos;
        var lightLoc:vec4<f32> = modelView * vec4<f32>(lightDirection, 1.0);
        out.lightLoc = lightLoc.xyz / lightLoc.w;

        return out;
    }
    
    // Fragment shader
    @group(0) @binding(9)
    var t_depth: texture_depth_2d;
    @group(0) @binding(10)
    var s_depth: sampler_comparison;
    @group(0) @binding(11)
    var<uniform> lightModelViewMatrix: mat4x4<f32>;
    @group(0) @binding(12)
    var<uniform> lightProjectionMatrix: mat4x4<f32>;

    @fragment
    fn fs_main(in: VertexOutput,   @builtin(front_facing) face: bool) -> @location(0) vec4<f32> {
        var lightLoc:vec3<f32> = in.lightLoc;
        var lightDir:vec3<f32> = normalize(in.lightDir);
        var n:vec3<f32> = normalize(in.normal);
        var viewDir: vec3<f32> = in.viewDir;

        var fragmentPosInScreenSpace: vec4<f32> = lightProjectionMatrix * lightModelViewMatrix * vec4(in.inPos, 1.0);
        fragmentPosInScreenSpace = fragmentPosInScreenSpace / fragmentPosInScreenSpace.w;
        var depth: f32 = fragmentPosInScreenSpace.z;
        var uv:vec2<f32> = 0.5*(fragmentPosInScreenSpace.xy + vec2(1.0,1.0));

        var visibility = 0.0;
            let oneOverShadowDepthTextureSize = 1.0 / 1024.0;
            for (var y = -2; y <= 2; y++) {
              for (var x = -2; x <= 2; x++) {
                let offset = vec2<f32>(vec2(x, y)) * oneOverShadowDepthTextureSize;
          
                visibility += textureSampleCompare(
                    t_depth, s_depth,
                    vec2(uv.x, 1.0-uv.y) + offset,depth  - 0.0003
                );
              }
            }
            visibility /= 25.0;

        if (face) {
            //if (depth < light2ClosestSurfaceDist+0.0001) {

                var wldLoc2light:vec3<f32> =   in.wldLoc-lightLoc;

                //var lightDir:vec3<f32> =  
                var align:f32 = dot( normalize(wldLoc2light),lightDir);

                if (align > 0.9) {
                    var radiance:vec3<f32>  = ambientColor.rgb * ambientReflectionConstant + 
                        diffuse(-lightDir, n, diffuseColor.rgb)* diffuseReflectionConstant +
                        specular(-lightDir, viewDir, n, specularColor.rgb, shininess) * specularReflectionConstant;
        
                    return vec4<f32>(radiance * visibility ,1.0);
                   // return vec4<f32>(0.0,0.0,light2ClosestSurfaceDist,1.0);
                }

                //return vec4<f32>(1.0,1.0,0.0,1.0);
            //}
          
        } 
            return vec4<f32>( 0.0,0.0,0.0,1.0);
        
    }
</script>

<script id="light_view_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) depth: f32
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>
    ) -> VertexOutput {
        var out: VertexOutput;

        var wldLoc:vec4<f32> = modelView * vec4<f32>(inPos, 1.0);
        out.clip_position = projection * wldLoc;
        out.depth = out.clip_position.z / out.clip_position.w;
        return out;
    }

    struct FragOutputs {
        @builtin(frag_depth) depth: f32,
        @location(0) color: vec4<f32>
      }
    
    // Fragment shader
    @fragment
    fn fs_main(in: VertexOutput,   @builtin(front_facing) isFront: bool) -> FragOutputs {
        var out:FragOutputs;
        if (isFront) {
            out.depth = in.depth;
        }
        else {
            out.depth = in.depth -0.001;
        }
        out.color = vec4<f32>(0.0,1.0,0.0,1.0);
        return out;
    }
</script>

<script id="skybox" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> modelView: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) worldPos: vec3<f32>
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec3<f32>
    ) -> VertexOutput {
        var out: VertexOutput;
        out.worldPos = inPos;
        var wldLoc:vec4<f32> = modelView * vec4<f32>(inPos, 1.0);
        out.clip_position = projection * wldLoc;
        return out;
    }
    
    // Fragment shader

    const pi:f32 = 3.141592654;
    @group(0) @binding(2)
    var t_diffuse: texture_2d<f32>;
    @group(0) @binding(3)
    var s_diffuse: sampler;

    @fragment
    fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
        var n:vec3<f32> = normalize(in.worldPos);

        var len:f32 = sqrt (n.x *n.x + n.y*n.y);

        var s:f32 = acos( n.x / len);

        if (n.y < 0) {
            s = 2.0 * pi - s;
        }

        s = s / (2.0 * pi);
        return textureSampleLevel(t_diffuse, s_diffuse, vec2(s , ((asin(n.z) * -2.0 / pi ) + 1.0) * 0.5), 0);
    }

</script>

<script>
    let angle = 0.0;

    class Skybox {
        constructor() {
            this.pipeline = null;
            this.positionBuffer = null;
            this.uniformBindGroup = null;
        }

        async setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer) {
            let shaderModule = shaderModuleFromCode(device, 'skybox');

            const positions = new Float32Array([
                100.0, -100.0, 50.0, -100.0, -100.0, 50.0, -100.0, 100.0, 50.0,
                -100.0, 100.0, 50.0, 100.0, 100.0, 50.0, 100.0, -100.0, 50.0,

                -100.0, 100.0, -50.0, -100.0, -100.0, -50.0, 100.0, -100.0, -50.0,
                100.0, -100.0, -50.0, 100.0, 100.0, -50.0, -100.0, 100.0, -50.0,


                -100.0, 50.0, -100.0, 100.0, 50.0, -100.0, -100.0, 50.0, 100.0,
                100.0, 50.0, 100.0, -100.0, 50.0, 100.0, 100.0, 50.0, -100.0,

                -100.0, -50.0, -100.0, -100.0, -50.0, 100.0, 100.0, -50.0, -100.0,
                100.0, -50.0, 100.0, 100.0, -50.0, -100.0, -100.0, -50.0, 100.0,


                50.0, 100.0, -100.0, 50.0, -100.0, -100.0, 50.0, -100.0, 100.0,
                50.0, -100.0, 100.0, 50.0, 100.0, 100.0, 50.0, 100.0, -100.0,

                -50.0, -100.0, 100.0, -50.0, -100.0, -100.0, -50.0, 100.0, -100.0,
                -50.0, 100.0, -100.0, -50.0, 100.0, 100.0, -50.0, -100.0, 100.0,

            ]);

            this.positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);

            const sampler = device.createSampler({
                addressModeU: 'repeat',
                addressModeV: 'repeat',
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear',
            });

            const texture = await img2texture(device, '../data/parking_lot.jpg');

            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {}
                    }
                ]
            });

            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: modelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: texture.createView()
                    },
                    {
                        binding: 3,
                        resource:
                            sampler

                    }
                ]
            });

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x3'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-list',
                    frontFace: 'ccw',
                    cullMode: 'back'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);
        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.draw(36, 1);
        }
    }

    class Teapot {
        constructor() {
            this.pipeline = null;
            this.lightPipeline = null;
            this.positionBuffer = null;
            this.normalBuffer = null;
            this.indexBuffer = null;
            this.uniformBindGroup = null;
            this.indexSize = null;
            this.uniformBindGroupLight = null;
        }

        async setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            depthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer) {
            let shaderModule = shaderModuleFromCode(device, 'object_with_shadow_shader');
            let shaderModuleLight = shaderModuleFromCode(device, 'light_view_shader');

            let { positionBuffer, normalBuffer, indexBuffer, indexSize } = await loadObj(device, '../data/teapot.obj');
            this.positionBuffer = positionBuffer;
            this.normalBuffer = normalBuffer;
            this.indexBuffer = indexBuffer;
            this.indexSize = indexSize;


            let uniformBindGroupLayoutLight = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    }
                ]
            });

            this.uniformBindGroupLight = device.createBindGroup({
                layout: uniformBindGroupLayoutLight,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: lightModelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: lightProjectionMatrixUniformBuffer
                        }
                    }
                ]
            });


            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 4,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 5,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 6,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 7,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 8,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 9,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {
                            sampleType: "depth"
                        }
                    },
                    {
                        binding: 10,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {
                            type: 'comparison',
                        },
                    },
                    {
                        binding: 11,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 12,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    }
                ]
            });

            const ambientUniformBuffer = createGPUBuffer(device, new Float32Array([0.15, 0.10, 0.10, 1.0]), GPUBufferUsage.UNIFORM);
            const diffuseUniformBuffer = createGPUBuffer(device, new Float32Array([0.55, 0.55, 0.55, 1.0]), GPUBufferUsage.UNIFORM);
            const specularUniformBuffer = createGPUBuffer(device, new Float32Array([1.0, 1.0, 1.0, 1.0]), GPUBufferUsage.UNIFORM);
            const shininessUniformBuffer = createGPUBuffer(device, new Float32Array([20.0]), GPUBufferUsage.UNIFORM);


            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: modelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: normalMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: lightDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 4,
                        resource: {
                            buffer: viewDirectionUniformBuffer
                        }
                    },
                    {
                        binding: 5,
                        resource: {
                            buffer: ambientUniformBuffer
                        }
                    },
                    {
                        binding: 6,
                        resource: {
                            buffer: diffuseUniformBuffer
                        }
                    },
                    {
                        binding: 7,
                        resource: {
                            buffer: specularUniformBuffer
                        }
                    },
                    {
                        binding: 8,
                        resource: {
                            buffer: shininessUniformBuffer
                        }
                    },
                    {
                        binding: 9,
                        resource: depthTexture.createView()
                    },
                    {
                        binding: 10,
                        resource:
                            sampler
                    },
                    {
                        binding: 11,
                        resource: {
                            buffer: lightModelViewMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 12,
                        resource: {
                            buffer: lightProjectionMatrixUniformBuffer
                        }
                    },
                ]
            });

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x3'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const normalAttribDesc = {
                shaderLocation: 1, // @location(1)
                offset: 0,
                format: 'float32x3'
            };

            const normalBufferLayoutDesc = {
                attributes: [normalAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, normalBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-list',
                    frontFace: 'ccw',
                    cullMode: 'none'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);

            const lightPipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayoutLight] };

            const lightPipelineDesc = {
                layout: device.createPipelineLayout(lightPipelineLayoutDesc),
                vertex: {
                    module: shaderModuleLight,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModuleLight,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-list',
                    frontFace: 'ccw',
                    cullMode: 'none'
                },
                depthStencil: {
                    depthWriteEnabled: true,
                    depthCompare: 'less',
                    format: 'depth32float'
                }
            };

            this.lightPipeline = device.createRenderPipeline(lightPipelineDesc);
        }

        encodeForLight(encoder) {
            encoder.setPipeline(this.lightPipeline);
            encoder.setBindGroup(0, this.uniformBindGroupLight);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setIndexBuffer(this.indexBuffer, 'uint16');
            encoder.drawIndexed(this.indexSize);
        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.normalBuffer);
            encoder.setIndexBuffer(this.indexBuffer, 'uint16');
            encoder.drawIndexed(this.indexSize);
        }
    }

    class Arcball {
        constructor() {
            this.radius = 8.0;
            this.forwardVector = glMatrix.vec4.fromValues(this.radius, 0.0, 0.0, 0.0);
            this.upVector = glMatrix.vec4.fromValues(0.0, 0.0, 1.0, 0.0);
            this.currentRotation = glMatrix.mat4.create();
        }

        yawPitch(originalX, originalY, currentX, currentY) {

            let originalPoint = glMatrix.vec3.fromValues(1.0, originalX, originalY);
            let newPoint = glMatrix.vec3.fromValues(1.0, currentX, currentY);

            let rotationAxis = glMatrix.vec3.cross(glMatrix.vec3.create(), originalPoint, newPoint);

            rotationAxis = glMatrix.vec4.fromValues(rotationAxis[0], rotationAxis[1], rotationAxis[2], 0.0);

            rotationAxis = glMatrix.vec4.transformMat4(glMatrix.mat4.create(), rotationAxis, this.currentRotation);

            rotationAxis = glMatrix.vec3.normalize(glMatrix.vec3.create(), glMatrix.vec3.fromValues(rotationAxis[0], rotationAxis[1], rotationAxis[2]));

            let sin = glMatrix.vec3.length(rotationAxis) / (glMatrix.vec3.length(originalPoint) * glMatrix.vec3.length(newPoint));

            let rotationMatrix = glMatrix.mat4.fromRotation(glMatrix.mat4.create(), Math.asin(sin) * -0.03, rotationAxis);

            if (rotationMatrix !== null) {
                this.currentRotation = glMatrix.mat4.multiply(glMatrix.mat4.create(), rotationMatrix, this.currentRotation);
                this.forwardVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.forwardVector, rotationMatrix);
                this.upVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.upVector, rotationMatrix);
            }
        }

        roll(originalX, originalY, currentX, currentY) {

            const originalVec = glMatrix.vec3.fromValues(originalX, originalY, 0.0);
            const currentVec = glMatrix.vec3.fromValues(currentX, currentY, 0.0);

            const crossProd = glMatrix.vec3.cross(glMatrix.vec3.create(), originalVec, currentVec);


            let rad = glMatrix.vec3.dot(glMatrix.vec3.normalize(glMatrix.vec3.create(), originalVec),
                glMatrix.vec3.normalize(glMatrix.vec3.create(), currentVec));

            if (rad > 1.0) {
                // cross product can be larger than 1.0 due to numerical error
                rad = Math.PI * Math.sign(crossProd[2]);
            }
            else {
                rad = Math.acos(rad) * Math.sign(crossProd[2]);
            }

            let rotationMatrix = glMatrix.mat4.fromRotation(glMatrix.mat4.create(), -rad, this.forwardVector);
            if (rotationMatrix !== null) {
                this.currentRotation = glMatrix.mat4.multiply(glMatrix.mat4.create(), rotationMatrix, this.currentRotation);
                this.upVector = glMatrix.vec4.transformMat4(glMatrix.vec4.create(), this.upVector, rotationMatrix);
            }
        }

        getMatrices() {
            let modelViewMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
                glMatrix.vec3.fromValues(this.forwardVector[0], this.forwardVector[1], this.forwardVector[2]),
                glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(this.upVector[0], this.upVector[1], this.upVector[2]));

            return modelViewMatrix;
        }
    }

    async function webgpu() {
        const adapter = await navigator.gpu.requestAdapter();

        let device = await adapter.requestDevice();

        let context = configContext(device, canvas);

        const sampler = device.createSampler({
            addressModeU: 'clamp-to-edge',
            addressModeV: 'clamp-to-edge',
            magFilter: 'linear',
            minFilter: 'linear',
            mipmapFilter: 'linear',
            compare: "less",
        });


        const lightDepthTextureDesc = {
            size: [1024, 1024, 1],
            dimension: '2d',
            format: 'depth32float',
            usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.COPY_SRC | GPUTextureUsage.TEXTURE_BINDING
        };

        let lightDepthTexture = device.createTexture(lightDepthTextureDesc);

        let arcball = new Arcball();

        let modelViewMatrix = arcball.getMatrices();

        let modelViewMatrixUniformBuffer = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let viewDir = glMatrix.vec3.fromValues(- 10.0, -10.0, -10);

        let viewDirectionUniformBuffer = createGPUBuffer(device, viewDir, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let lightDirectionUniformBuffer = createGPUBuffer(device, viewDir, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);


        let modelViewMatrixInverse = glMatrix.mat4.invert(glMatrix.mat4.create(), modelViewMatrix);

        let normalMatrix = glMatrix.mat4.transpose(glMatrix.mat4.create(), modelViewMatrixInverse);

        let normalMatrixUniformBuffer = createGPUBuffer(device, normalMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let projectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
            1.4, 640.0 / 480.0, 0.1, 1000.0);

        let projectionMatrixUniformBuffer = createGPUBuffer(device, projectionMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);


        let lightProjectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
            Math.acos(0.9) * 2.0, 1.0, 1.0, 100.0);

        let lightProjectionMatrixUniformBuffer = createGPUBuffer(device, lightProjectionMatrix, GPUBufferUsage.UNIFORM);

        let lightModelViewMatrixUniformBuffer = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let teapot = new Teapot();
        await teapot.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer, normalMatrixUniformBuffer, viewDirectionUniformBuffer, lightDirectionUniformBuffer,
            lightDepthTexture, sampler, lightModelViewMatrixUniformBuffer, lightProjectionMatrixUniformBuffer);

        let skybox = new Skybox();
        await skybox.setup(device, modelViewMatrixUniformBuffer, projectionMatrixUniformBuffer);

        let depthTexture = null;

        let lightDepthAttachment = {
            view: lightDepthTexture.createView(),
            depthClearValue: 1,
            depthLoadOp: 'clear',
            depthStoreOp: 'store'
        };

        const lightColorTextureDesc = {
            size: [1024, 1024, 1],
            dimension: '2d',
            format: 'bgra8unorm',
            usage: GPUTextureUsage.RENDER_ATTACHMENT
        };

        let lightColorTexture = device.createTexture(lightColorTextureDesc);

        let lightColorAttachment = {
            view: lightColorTexture.createView(),
            clearValue: { r: 1, g: 0, b: 0, a: 1 },
            loadOp: "load",
            storeOp: 'store'
        }

        const lightRenderPassDesc = {
            colorAttachments: [lightColorAttachment],
            depthStencilAttachment: lightDepthAttachment
        };

        let copiedBuffer = createGPUBuffer(device, new Float32Array(1024 * 1024), GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);

        async function render() {
            const devicePixelRatio = window.devicePixelRatio || 1;
            let currentCanvasWidth = canvas.clientWidth * devicePixelRatio;
            let currentCanvasHeight = canvas.clientHeight * devicePixelRatio;

            let projectionMatrixUniformBufferUpdate = null;

            if (depthTexture === null || currentCanvasWidth != canvas.width || currentCanvasHeight != canvas.height) {
                canvas.width = currentCanvasWidth;
                canvas.height = currentCanvasHeight;

                if (depthTexture !== null) {
                    depthTexture.destroy();
                }

                const depthTextureDesc = {
                    size: [canvas.width, canvas.height, 1],
                    dimension: '2d',
                    format: 'depth32float',
                    usage: GPUTextureUsage.RENDER_ATTACHMENT
                };

                depthTexture = device.createTexture(depthTextureDesc);
                let depthTextureView = depthTexture.createView();

                depthAttachment = {
                    view: depthTextureView,
                    depthClearValue: 1,
                    depthLoadOp: 'clear',
                    depthStoreOp: 'store'
                };

                let projectionMatrix = glMatrix.mat4.perspective(glMatrix.mat4.create(),
                    1.4, canvas.width / canvas.height, 0.1, 1000.0);

                projectionMatrixUniformBufferUpdate = createGPUBuffer(device, projectionMatrix, GPUBufferUsage.COPY_SRC);
            }

            let modelViewMatrix = arcball.getMatrices();

            let modelViewMatrixUniformBufferUpdate = createGPUBuffer(device, modelViewMatrix, GPUBufferUsage.COPY_SRC);

            let modelViewMatrixInverse = glMatrix.mat4.invert(glMatrix.mat4.create(), modelViewMatrix);

            let normalMatrix = glMatrix.mat4.transpose(glMatrix.mat4.create(), modelViewMatrixInverse);

            let normalMatrixUniformBufferUpdate = createGPUBuffer(device, normalMatrix, GPUBufferUsage.COPY_SRC);

            let viewDir = glMatrix.vec3.fromValues(-arcball.forwardVector[0], -arcball.forwardVector[1], -arcball.forwardVector[2]);
            let viewDirectionUniformBufferUpdate = createGPUBuffer(device, viewDir, GPUBufferUsage.COPY_SRC);

            let lightDir = glMatrix.vec3.fromValues(Math.cos(angle) * 8.0, Math.sin(angle) * 8.0, 10);
            let lightDirectionUniformBufferUpdate = createGPUBuffer(device, lightDir, GPUBufferUsage.COPY_SRC);

            let lightModelViewMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
                glMatrix.vec3.fromValues(Math.cos(angle) * 8.0, Math.sin(angle) * 8.0, 10),
                glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(0.0, 0.0, 1.0));

            let lightModelViewMatrixUniformBufferUpdate = createGPUBuffer(device, lightModelViewMatrix, GPUBufferUsage.COPY_SRC);


            let colorTexture = context.getCurrentTexture();
            let colorTextureView = colorTexture.createView();

            let colorAttachment = {
                view: colorTextureView,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
            };

            let colorAttachment2 = {
                view: colorTextureView,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: "load",
                storeOp: 'store'
            }

            const renderPassDesc = {
                colorAttachments: [colorAttachment],
                depthStencilAttachment: depthAttachment
            };

            const renderPassDesc2 = {
                colorAttachments: [colorAttachment2]
            };

            commandEncoder = device.createCommandEncoder();
            if (projectionMatrixUniformBufferUpdate) {
                commandEncoder.copyBufferToBuffer(projectionMatrixUniformBufferUpdate, 0,
                    projectionMatrixUniformBuffer, 0, projectionMatrix.byteLength);
            }
            commandEncoder.copyBufferToBuffer(lightModelViewMatrixUniformBufferUpdate, 0,
                lightModelViewMatrixUniformBuffer, 0, lightModelViewMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(modelViewMatrixUniformBufferUpdate, 0,
                modelViewMatrixUniformBuffer, 0, modelViewMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(normalMatrixUniformBufferUpdate, 0,
                normalMatrixUniformBuffer, 0, normalMatrix.byteLength);
            commandEncoder.copyBufferToBuffer(viewDirectionUniformBufferUpdate, 0,
                viewDirectionUniformBuffer, 0, viewDir.byteLength);
            commandEncoder.copyBufferToBuffer(lightDirectionUniformBufferUpdate, 0,
                lightDirectionUniformBuffer, 0, lightDir.byteLength);

            const lightPassEncoder = commandEncoder.beginRenderPass(lightRenderPassDesc);
            lightPassEncoder.setViewport(0, 0, 1024, 1024, 0, 1);
            teapot.encodeForLight(lightPassEncoder);
            lightPassEncoder.end();
            commandEncoder.copyTextureToBuffer({ texture: lightDepthTexture, origin: { x: 0, y: 0 } }, { buffer: copiedBuffer, bytesPerRow: 1024 * 4 }, { width: 1024, height: 1024 });
            //device.queue.submit([commandEncoder.finish()]);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
            passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            skybox.encode(passEncoder);
            teapot.encode(passEncoder);

            passEncoder.end();

            device.queue.submit([commandEncoder.finish()]);


            await device.queue.onSubmittedWorkDone();

            if (projectionMatrixUniformBufferUpdate) {
                projectionMatrixUniformBufferUpdate.destroy();
            }
            modelViewMatrixUniformBufferUpdate.destroy();
            normalMatrixUniformBufferUpdate.destroy();
            viewDirectionUniformBufferUpdate.destroy();
            lightDirectionUniformBufferUpdate.destroy();
            lightModelViewMatrixUniformBufferUpdate.destroy();
            angle += 0.01;
            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        let prevX = 0.0;
        let prevY = 0.0;
        let isDragging = false;
        const yawPitch = 1;
        const roll = 2;

        canvas.onmousedown = (event) => {
            var rect = canvas.getBoundingClientRect();
            const x = event.clientX - rect.left;
            const y = event.clientY - rect.top;

            const width = rect.right - rect.left;
            const height = rect.bottom - rect.top;

            let radius = width;

            if (height < radius) {
                radius = height;
            }

            radius *= 0.5;

            const originX = width * 0.5;
            const originY = height * 0.5;

            prevX = (x - originX) / radius;
            prevY = (originY - y) / radius;

            if ((prevX * prevX + prevY * prevY) < 0.64) {
                isDragging = yawPitch;
            }
            else {
                isDragging = roll;
            }

        }

        canvas.onmousemove = (event) => {
            if (isDragging != 0) {
                var rect = canvas.getBoundingClientRect();
                const x = event.clientX - rect.left;
                const y = event.clientY - rect.top;

                const width = rect.right - rect.left;
                const height = rect.bottom - rect.top;

                let radius = width;

                if (height < radius) {
                    radius = height;
                }

                radius *= 0.5;

                const originX = width * 0.5;
                const originY = height * 0.5;

                currX = (x - originX) / radius;
                currY = (originY - y) / radius;

                if (isDragging == yawPitch) {
                    arcball.yawPitch(prevX, prevY, currX, currY);
                }
                else if (isDragging == roll) {
                    arcball.roll(prevX, prevY, currX, currY);
                }
                prevX = currX;
                prevY = currY;
                //requestAnimationFrame(render);
            }
        }

        canvas.onmouseup = (event) => {
            isDragging = 0;
        }
    }

    webgpu();
</script>

</html>