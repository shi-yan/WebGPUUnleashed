<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <!-- Primary Meta Tags -->
    <title>: WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/Basics/drawing_a_triangle.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/Basics/drawing_a_triangle.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/html.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />

    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    </script>
</head>

<body>
    <nav role="navigation">
        <div id="menuToggle">
            <input type="checkbox" />
            <span></span>
            <span></span>
            <span></span>
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                        <li><a href="/WebGPUUnleashed/Control/error_handling_and_limits.html">Error Handling and Limits</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
            </ul>
        </div>
    </nav>
    <div id="article-container">
        <article>
            <h2 >1.1 Drawing a Triangle</h2><p>Our first tutorial is a bit boring as we weren't drawing anything. In this tutorial, we will draw a single triangle.</p><p>In the realm of 3D rendering, triangles serve as the most foundational elements to draw. They stand as the pixels of a 3D world, making them an ideal starting point for our first tutorial. Here, we will learn how to draw a single triangle. Our journey will involve crafting a straightforward shader to define pixel colors within a triangle, along with understanding how to establish a graphics pipeline that takes this triangle and renders it on the screen using the shader. Just like the "Hello World" program in traditional programming, drawing a triangle serves as the equivalent introduction to any graphics API.</p><p>In our previous example, we didn't create any shader. As mentioned before, a shader program is a program executed on GPU. The sole purpose of a shader is given geometry primitives, such as points or triangles, it converts them into pixels.</p><p>First, let's create another script tag in our html. This time, we set its type to <code>wgsl</code>. In addition to the type, we also need an id <code>shader</code>, because later we will need it to read its content.</p><pre><code class="language-html code-block">&lt;script id="shader" type="wgsl"&gt;
// Vertex shader

struct VertexOutput {
    @builtin(position) clip_position: vec4&lt;f32&gt;,
};

@vertex
fn vs_main(
    @builtin(vertex_index) in_vertex_index: u32,
) -&gt; VertexOutput {
    var out: VertexOutput;
    let x = f32(1 - i32(in_vertex_index)) * 0.5;
    let y = f32(i32(in_vertex_index &amp; 1u) * 2 - 1) * 0.5;
    out.clip_position = vec4&lt;f32&gt;(x, y, 0.0, 1.0);
    return out;
}

// Fragment shader

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    return vec4&lt;f32&gt;(0.3, 0.2, 0.1, 1.0);
}

&lt;/script&gt;</code></pre><p>our first shader renders a triangle in a solid color. despite sounding simple, the code seems to be complex. Let me dissect it for you.</p><p>A shader program defines the behavior of a gpu pipeline. A gpu pipeline works like a small factory, it contains a series of stages or workshops. A typical gpu pipeline contains 2 stages, a vertex stage that processes geometry data and generate canvas aligned geometries. The gpu then converts them into fragments and send them to the Fragment shader for coloring. The fragment shader generates an RGB value for a given fragment.</p><p>In the above code, there are two functions, vs_main represents the vertex stage, and it is annotated by <code>@vertex</code> and fs_main is the fragment stage annotated by <code>@fragment</code>. The input to the vs_main function looks similar to one you might see in a different programming language, such as c <code>@builtin(vertex_index) in_vertex_index: u32</code>, but it is different. Here <code>in_vertex_index</code> is the variable's name, and <code>u32</code> is the type, a 32bit unsigned int. But what <code>@builtin(vertex_index)</code> is?</p><p>Actually, the inputs only look like function parameters, but they are predefined. Imagine there is a predefined form with several fields, each field has a label, and <code>@builtin(vertex_index)</code> is one of the field's label. Hence, for a pipeline stage's inputs, we are not free to feed any data, we have to pick a few from the predefined table. in the above code, <code>@builtin(vertex_index)</code> is the actual parameter name, and <code>in_vertex_index</code> is just an alias for it.</p><p><code>@builtin</code> indicates a group of predefined fields. But there is also <code>@location</code>, which we will discuss their differences later.</p><p>For the outputs of a shader stage, it's the same. We are not free to output anything, but choose a few predefined fields to populate. Here in this example, we are outputting a <code>struct VertexOutput</code>, but inside it, there is a single field <code>@builtin(position)</code>, which we will write result to.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="coord2.png" alt="The Screen Space Coordinate System." sources='[]' /><div class="img-title">The Screen Space Coordinate System.</div></div></p><p>The content of the vertex shader is a bit puzzling. Before we get to it, let me first explain the goal of a vertex shader. Usually a vertex shader receives geometries in the form of individual vertices. We do not have the geometry connectivity information at this stage, i.e. we don't know which vertices are connected to form a triangle. This information is omitted from us. What we are processing are individual vertices and our goal is converting their position to be aligned on the canvas, because if we render them as they are without any position transformation, they may not be visible because first, the vertices might be defined in their own coordinate system that is different from the canvas'. A vertex's coordinates might be outside the visible area of the canvas. To see it, we need to at least move and scale their coordinates, so that they fall onto the canvas' coordinate system. Second, vertices can present in a 3D space whereas the canvas is always 2D. We need a conversion, called projection, to transform the 3D coordinates into 2D.</p><p>At this point, we need to look at the coordinate system of the canvas. This is usually termed as the screen space, or the clip space. But for WebGPU, we usually render things into a canvas rather than directly onto screen, but I'm calling it the screen space coordinate system, as this term is more commonly used.</p><p>The coordinate system has the origin in the center, and both the x and y coordinates confined within the [-1,1] range. No matter what your screen or canvas size is, the coordinate system stays the same. you can define a canvas viewport, but this won't affect the coordinate system. As long as a vertex's coordinates fall inside the range of [-1,1], the vertex is visible. The rendering pipeline will stretch its location and map it on the viewport you define. Let's say you have a viewport of 640x480. Even the aspect ratio is 4/3, the canvas coordinate system is still [-1,1] for both x and y. now if you draw a vertex at the location (1,1), it will appear at the upper right corner. But when presented on the canvas, the location (1,1) will be stretched to (640,480).</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="coord.png" alt="The Visible Area Remains Constant Regardless of Screen Size or Aspect Ratio." sources='[]' /><div class="img-title">The Visible Area Remains Constant Regardless of Screen Size or Aspect Ratio.</div></div></p><p>In the above code, however, our inputs are vertex indices, not their positions. Instead of transforming vertices' position, we generate their position by their index. Since we are drawing a triangle, which has 3 vertices, the indices will be 0,1,2. What we are doing there is generating one unique position for each index and make sure the position is within the [-1,1] range, so that the entire triangle will be visible. If we subsitude 0,1,2 with vertex_index, we will get (0.5,-0.5), (0,0.5), (-0.5,-0.5).</p><p>the clip location is a 4 float vector, rather than 2. The third component is always zero, as we are generating a screen space 2d triangle. The last value is xxx</p><p>The Fragment shader accepts what the vertex shader outputs, as it is the next stage after vertex shader on the gpu pipeline. the output of the fragment shader is another predefined field called <code>@location(0)</code>, each location can save a value up to 16 bytes, i.e. 4 32bit floats. The overall number of locations is defined by the WebGPU implementation. What's the difference between locations and builtins. We can view locations as unstructured custom data. There is no label for them other than an index. This is parallel to the http protocol where we have a structured message head, which is similar to the builtins, and followed by the body or payload, which can be anything. Or if you have experience decoding a binary file, which usually has a structured header with metadata, followed by a chunk of data as the payload. Here builtins and locations share the same concept.</p><p>The fragment shader is rather simple, it simply outputs a solid color to <code>@location(0)</code>.</p><pre><code class="language-html code-block">&lt;script&gt;
    async function webgpu() {
        ...

        let code = document.getElementById('shader').innerText;

        const shaderDesc = { code: code };
        let shaderModule = device.createShaderModule(shaderDesc);

        ...
    }

    webgpu();
&lt;/script&gt;</code></pre><p>// <a class="link" href="https://toji.dev/webgpu-best-practices/error-handling.html" target="_blank">https://toji.dev/webgpu-best-practices/error-handling.html</a></p><p>Writing the shader code isn't the only thing required to render a simple triangle. Next, let's look at how to modify the pipeline to adopt the shader code. The first thing is compiling the code. The first step is fetching the source code string from our first script tag. This is where the tag's <code>id='shader'</code> comes into play. Next, we create a shader description wich contains the source code. Finally, we create a shader module by providing the shader description. Here we don't have any error handling. We might talk about error handling in a dedicated chapter. If we ran into a compiling error, we will end up have an invalid shader module. The browser's console message is very helpful in debugging issues like this. Since for most of the cases, the shader code is defined by the developer at the development stage, we are likely to ship the code when all shader issues are resolved during development. Hence we omit error handling here.</p><pre><code class="language-html code-block">&lt;script&gt;
    async function webgpu() {
        ...

        const pipelineLayoutDesc = { bindGroupLayouts: [] };
        const layout = device.createPipelineLayout(pipelineLayoutDesc);

        ...
    }

    webgpu();
&lt;/script&gt;</code></pre><p>Next we define the pipline layout. What's pipeline layout? It refers to the format of the constants we want to provide to the pipeline. Those contants are organized into groups, hence the bindGroupLayouts is a list. And the constants stay the same value during the execuation of the pipeline. In our example, we are not providing any constants at all, hence the pipeline layout is empty.</p><pre><code class="language-html code-block">&lt;script&gt;
    async function webgpu() {
        ...

        const colorState = {
            format: 'bgra8unorm'
        };

        ...
    }

    webgpu();
&lt;/script&gt;</code></pre><p>The next step is specifying the output pixel format.</p><pre><code class="language-html code-block">&lt;script&gt;
    async function webgpu() {
        ...

        const pipelineDesc = {
            layout,
            vertex: {
                module: shaderModule,
                entryPoint: 'vs_main',
                buffers: []
            },
            fragment: {
                module: shaderModule,
                entryPoint: 'fs_main',
                targets: [colorState]
            },
            primitive: {
                topology: 'triangle-list',
                frontFace: 'ccw',
                cullMode: 'back'
            }
        };

        pipeline = device.createRenderPipeline(pipelineDesc);

        ...
    }
    webgpu();
&lt;/script&gt;</code></pre><p>After that, we have gathered everything required for creating the pipeline. Similar to a real factory pipeline, a gpu pipeline is about inputs, a series of workshops, and the end products. Using that analogy, <code>layout</code> and <code>primitive</code> describe the input data formats. As mentioned, the <code>layout</code> is referring to the constants, and <code>primitive</code> specifies how the geometry primitives should be provided. We provide the input geometry in the form of a list of vertices. But as we previously mentioned, the elements of 3D graphics are triangles. How a list of triangles can be interpreted as triangles are defined here by the <code>topology</code> field. For example, <code>triangle-list</code> means a list of triangles. Each triangle has a front side and a back side. Here we can specify that the counter-clockwise vertex order should be treated as the front side, which means if we are facing a triangle and its 3 vertices form a counter-clockwise order, then we are looking at its front side. Finally, the <code>cullMode</code> means if we want to eliminate the rendering of a side of the triangle. <code>back</code> means we do not want to render the back side of a triangle. For most of the cases, the back side of triangles shouldn't be rendered, as they are often invisible. This can save computation.</p><p>(here show a diagram of triangles)</p><p>using a Triangle list topology is the most straightforward way of representing triangles, but it is not the most efficient way, as shown in the following diagram, when we want to feed a strip formed by connected triangles, many of its vertices are shared by more than one triangles. We want to be able to reuse their positions for multiple triangles, instead of sending the same position multiple times for different triangles. A triangle-strip is a better choice in this senario. We will see more topology types in future chapters.</p><pre><code class="language-html code-block">&lt;script&gt;
    async function webgpu() {
        ...
        commandEncoder = device.createCommandEncoder();

        passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
        passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
        passEncoder.setPipeline(pipeline);
        passEncoder.draw(3, 1);
        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
    }

    webgpu();
&lt;/script&gt;
</code></pre><p>With the pipeline defined, we need to create the <code>colorAttachment</code>, this is the same as what we have seen in the first tutorial, hence I omit the details here. After that, the final step is command creation and submission. It's pretty much the same as before, the difference is specifying to use the pipeline we have created and also calling the <code>draw()</code> function.</p><p>The draw function is the trigger for rendering, the two parameters mean the count of triangle vertices we want to render. And the second, is the instance count. You may want to ask, we are rendering one triangle, hence we want to render 3 vertices. This is easy to understand, but where do we pass in the positions of those vertices? They are actually derived by the vertex indices in the vert_main function in the shader. The vertex indices will be automatically generated before we call the vertex shader.</p><p>The instance count is a way to duplicate the same triangles multiple times. It's a way of speeding up rendering when we need to draw multiple instances of the same group of triangles. Here we only specify one instance as we only need to draw a single triangle in this example.</p>
        </article>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

<script type="module">
    const macros = {};
    const mathElementsBlock = document.getElementsByClassName("math-block");
    for (let element of mathElementsBlock) {
        katex.render(element.textContent, element, {
            throwOnError: false,
            displayMode: true,
            macros
        });
    }

    const mathElementsInline = document.getElementsByClassName("math-inline");
    for (let element of mathElementsInline) {
        katex.render(element.textContent, element, {
            throwOnError: false,
            macros
        });
    }

    hljs.highlightAll();

</script>
</body>

</html>