<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/WebGPUUnleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >5.5 Transparency with Depth Peeling</h2><p>Transparency is another fundamental visual effect not supported by 3D graphics APIs out of the box, and its implementation is not trivial. Previously, I introduced alpha blending and used it to achieve certain semi-transparent effects, such as when rendering text. However, when it comes to 3D objects, alpha blending alone will not yield the correct result.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#5_05_transparency" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 5_05_transparency</a><p>The fundamental issue is that depth testing is required to implement occlusion, but it conflicts with transparency rendering. Imagine a 3D scene with both opaque and transparent objects. If we disable depth testing, occlusion will not be rendered properly. However, if we enable depth testing, transparent objects in front of opaque objects will occlude the opaque objects. The correct rendering should allow transparent objects to overlay the opaque ones, allowing us to see through the transparent objects to the opaque ones behind them.</p><p>One naive idea is to draw the scene's objects in order from back to front, with depth testing applied only to each individual object, and turned off when overlaying objects on top of others. If you have used Photoshop before, this is similar to the concept of layers. The problem is that in certain situations, it's difficult to order objects. For example:</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_chain.png" original_src="chain.png" alt="Inter Linked Chain" sources='[]' /><div class="img-title">Inter Linked Chain</div></div></p><p>If ordering objects is not a good solution, you might consider ordering the triangles. However, like ordering objects, determining the order of triangles can be difficult. For example:</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_intersectplane.png" original_src="intersectplane.png" alt="Intersected Planes" sources='[]' /><div class="img-title">Intersected Planes</div></div></p><p>In this tutorial, we will explore a better technique called depth peeling. The idea is similar to Photoshop's layers, but instead of treating objects or triangles as layers, we peel the scene from the front to the back, placing each peeled scene as a layer and composing them together to form the final rendering.</p><p>Let me explain what I mean by peeling the scene. First, we render the scene with depth testing. This will render the front-most objects regardless of transparency. At the same time, we keep the depth map. The rendering result will be Layer Zero. Then, we render the scene again, but only render fragments that are behind the first depth map, i.e., the depth is larger than the initial depth value. The result is that we have peeled away the front-most fragments and revealed the second layer of fragments, which we call Layer One. Similarly, we keep this new depth map. From now on, we repeat the procedure, rendering the scene again and keeping fragments only when their depth value is larger than the current depth map. This will be Layer Two, and so on.</p><p>In the end, we will break down the scene into a set of layers based on depth. In the final pass, we compose the layers from front to back using alpha blending to create the final result.</p><p>The key concept of depth peeling is not difficult. One crucial aspect of understanding it thoroughly is grasping the alpha blending formula used for front-to-back blending.</p><p>I have worked in the field of computer graphics for many years, but I must admit, I found alpha blending and concepts like premultiplied alpha, back-to-front blending, and front-to-back blending confusing. While it's easy to find online resources that provide the formulas for different situations, truly understanding the underlying principles is crucial for handling more complex cases.</p><p>I want to express my gratitude to the book <a class="link" href="https://www.amazon.com/Advanced-Graphics-Programming-Kaufmann-Computer/dp/1558606599" target="_blank">Advanced Graphics Programming Using OpenGL</a>, which features a dedicated chapter that patiently explains how alpha blending works (starting on page 185).</p><p>My earlier confusion stemmed from conceptualizing alpha as opacity, similar to how we perceive transparency in real life. For example, imagining a semi-transparent red film, where red is the color and alpha represents the semi-transparency. This misconception made it difficult for me to grasp concepts like premultiplied alpha. In real life, an object's color is generally unrelated to its transparency – a very transparent red film should still appear red. However, in computer graphics, we have the concept of premultiplied alpha, where we multiply the alpha value with the color, causing a very transparent red to appear dark red or even black.</p><p>The correct way to conceptualize alpha is as the "amount of color" rather than opacity. In computer graphics, there is no true transparency; it's more akin to painting, where all pigments are fully opaque, differing only in color.</p><p>To create the illusion of semi-transparency, we must mix colors by taking a weighted average of existing colors, simulating the effect of light passing through multiple layers of color. When mixing colors, the only controllable factor is the amount of color, which corresponds to the alpha channel of an RGBA pixel.</p><p>Thus, the most basic form of alpha blending between two colors is:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{aligned}
C_{new} &= C_{src} * A_{src} + C_{dst} * (1 - A_{src}) \\
A_{new} &= 1.0
\end{aligned}</code></p><p>This describes a typical weighted average of two colors, assuming both colors and the resulting color
C_new are fully opaque. In this case, only C_src has an alpha value and is used in the formula, while C_dst and C_new have an alpha of 1.0 (full opacity). If C_src is the foreground color, the formula determines how much of the foreground color will be visible, without actual transparency involved.</p><p>We can think of each pixel as a small color bucket, where the amount of color poured into a single bucket cannot exceed 1.0 (i.e., no overflow).</p><p>When mixing two colors, we can imagine all pixel buckets initially containing the background color
C_dst at full opacity (1.0). To make room for adding the foreground color with an alpha value A_src, we need to remove some of the existing color. To ensure the resulting bucket remains full, the amount to remove should be 1.0−A_src.</p><p>When blending more than two colors additively, we must adjust the formula because we cannot assume that the resulting color at each step has no alpha (i.e., always a full bucket).</p><p>As we add colors to this bucket, we must account for the amount of color already present. This is why it is necessary to keep track of the current color amount in the bucket.</p><p>Let's label the colors to be blended as C_1, C_2, C_3, and so on. The formula for blending multiple colors becomes:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{aligned}
C_{new} &= C_1 * A_1 + C_2 * A_2 * (1.0 - A_1) \\
A_{new} &= A_1 + A_2 * (1.0 - A_1)
\end{aligned}</code></p><p>The weighted average of the two colors remains the same, but now we multiply C_2 by its alpha A_2 because C_2 is not fully opaque.</p><p>The new alpha formula, A_new = A_1 + A_2 * (1.0−A_1), ensures that the new alpha never exceeds 1.0, preventing overflow.</p><p>At first glance, the common equations for front-to-back alpha blending found online might not seem to match the above formula. However, they are actually equivalent. In front-to-back alpha blending, the destination color is the foreground, and the source is the background. The following formula uses
A_dst to store the (1.0−A_1) term from the above equation. By substituting C_src and A_src with C_2 and A_2, and C_dst and A_dst with C_1 and (1.0−A_1), we obtain the same equation:</p><p class="katex-display-counter"><code class="language-math math-block">\begin{aligned}
C_{dst} &= A_{dst} * (A_{src} * C_{src}) + C_{dst} \\
A_{dst} &= (1 - A_{src}) * A_{dst}
\end{aligned}</code></p><p>Now that we have clarified the blending equation, let's look at the implementation:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=96>@group(0) @binding(0)
var&lt;uniform&gt; modelView: mat4x4&lt;f32&gt;;
@group(0) @binding(1)
var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
@group(0) @binding(2)
var&lt;uniform&gt; normalMatrix: mat4x4&lt;f32&gt;;
@group(0) @binding(3) 
var&lt;uniform&gt; lightDirection: vec3&lt;f32&gt;;
@group(0) @binding(4)
var&lt;uniform&gt; viewDirection: vec3&lt;f32&gt;;

@group(1) @binding(0)
var&lt;uniform&gt; offset: vec3&lt;f32&gt;;
@group(1) @binding(1)
var&lt;uniform&gt; ambientColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(0.15, 0.10, 0.10, 1.0);
@group(1) @binding(2)
var&lt;uniform&gt; diffuseColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(0.55, 0.55, 0.55, 1.0);
@group(1) @binding(3)
var&lt;uniform&gt; specularColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0);

@group(1) @binding(4)
var&lt;uniform&gt; shininess:f32;// = 20.0;
    
const diffuseConstant:f32 = 1.0;
const specularConstant:f32 = 1.0;
const ambientConstant: f32 = 1.0;

fn specular(lightDir:vec3&lt;f32&gt;, viewDir:vec3&lt;f32&gt;, normal:vec3&lt;f32&gt;,  specularColor:vec3&lt;f32&gt;, 
     shininess:f32) -&gt; vec3&lt;f32&gt; {
    let reflectDir:vec3&lt;f32&gt; = reflect(-lightDir, normal);
    let specDot:f32 = max(dot(reflectDir, viewDir), 0.0);
    return pow(specDot, shininess) * specularColor;
}

fn diffuse(lightDir:vec3&lt;f32&gt;, normal:vec3&lt;f32&gt;,  diffuseColor:vec3&lt;f32&gt;) -&gt; vec3&lt;f32&gt;{
    return max(dot(lightDir, normal), 0.0) * diffuseColor;
}

struct VertexOutput {
    @builtin(position) clip_position: vec4&lt;f32&gt;,
    @location(0) viewDir: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
    @location(2) lightDir: vec3&lt;f32&gt;,
    @location(3) inPos: vec4&lt;f32&gt;,
};

@vertex
fn vs_main(
    @location(0) inPos: vec3&lt;f32&gt;,
    @location(1) inNormal: vec3&lt;f32&gt;
) -&gt; VertexOutput {
    var out: VertexOutput;

    out.viewDir = normalize((normalMatrix * vec4&lt;f32&gt;(-viewDirection, 0.0)).xyz);
    out.lightDir = normalize((normalMatrix * vec4&lt;f32&gt;(-lightDirection, 0.0)).xyz);
    out.normal = normalize(normalMatrix * vec4&lt;f32&gt;(inNormal, 0.0)).xyz;  
    var wldLoc:vec4&lt;f32&gt; = modelView * vec4&lt;f32&gt;(inPos+offset, 1.0);
    out.clip_position = projection * wldLoc;
    out.inPos = projection * wldLoc;
    return out;
}

@group(2) @binding(0)
var t_depth: texture_depth_2d;
@group(2) @binding(1)
var s_depth: sampler_comparison;
@group(2)
@binding(2)
var&lt;storage,read_write&gt; debug: vec4&lt;f32&gt;;

@fragment
fn fs_main(in: VertexOutput,  @builtin(front_facing) face: bool) -&gt; @location(0) vec4&lt;f32&gt; {
    var uv:vec2&lt;f32&gt; = 0.5*(in.inPos.xy/in.inPos.w + vec2(1.0,1.0));
    var visibility:f32 = textureSampleCompare(
        t_depth, s_depth,
        vec2(uv.x, 1.0-uv.y),  in.clip_position.z - 0.0001
    );

    debug = in.clip_position;
    //debug = in.inPos;
    //debug = vec4(uv,in.inPos.z/in.inPos.w, in.clip_position.z);
    if (visibility &lt; 0.5) {
        discard;
    }

    var lightDir:vec3&lt;f32&gt; = normalize(in.lightDir);
    var n:vec3&lt;f32&gt; = normalize(in.normal);

    var color:vec3&lt;f32&gt; = diffuseColor.rgb;

    if (!face) {
        n = normalize(-in.lightDir);
      //  color = vec3&lt;f32&gt;(0.0, 1.0, 0.0);
    }
    var viewDir: vec3&lt;f32&gt; = in.viewDir;

    var radiance:vec3&lt;f32&gt;  = ambientColor.rgb * ambientConstant + 
                    diffuse(-lightDir, n, color)* diffuseConstant +
                    specular(-lightDir, viewDir, n, specularColor.rgb, shininess) * specularConstant;
    //return vec4&lt;f32&gt;(uv.xy,0.0,1.0);
    return vec4&lt;f32&gt;(radiance * diffuseColor.w, diffuseColor.w);
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=95:196#5_05_transparency">5_05_transparency/index.html:96-197 Depth Peeling Shader</a></div></div><p>This shader should look familiar. It is similar to the lighting shader with a minor modification. This shader loads a depth map and compares the current depth value with the value in the depth map. It renders the fragment only when the new depth is greater than the depth in the map, which allows us to peel away objects before the depth map.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=153>out.clip_position = projection * wldLoc;
out.inPos = projection * wldLoc;
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=168>var uv:vec2&lt;f32&gt; = 0.5*(in.inPos.xy/in.inPos.w + vec2(1.0,1.0));
var visibility:f32 = textureSampleCompare(
    t_depth, s_depth,
    vec2(uv.x, 1.0-uv.y),  in.clip_position.z - 0.0001
);

debug = in.clip_position;
//debug = in.inPos;
//debug = vec4(uv,in.inPos.z/in.inPos.w, in.clip_position.z);
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=152:153,167:175#5_05_transparency">5_05_transparency/index.html:153-176 Calculate Depth and Uv Coordinates</a></div></div><p>It’s worth noting the logic used to calculate the UV coordinates for depth map fetching and the current depth. You might find it unusual that I have two variables, clip_position and inPos, both seemingly storing the clip space position vector. They appear to be duplicates.</p><p>This is intentional to illustrate that the clip_position variable passed into the vertex shader undergoes changes before reaching the fragment shader. Consequently, when we read it back in the fragment shader, it is not the same clip position, despite having the same variable name.</p><p>Recall when we introduced the GPU pipeline, we learned that during the vertex shader stage, we only define properties sparsely for each vertex. Then, during a step called rasterization, we convert triangle geometries into fragments, similar to laying bricks. The values defined at each fragment are obtained through bilinear interpolation. While interpolation explains some of the value changes, it does not account for all of them. Another significant change is that the pipeline alters the coordinate system. For x and y, the pipeline converts from clip space to normalized device coordinates, and then from normalized device coordinates to framebuffer coordinates (where the top-left corner is at (0.0, 0.0), with x increasing to the right and y increasing downward). For z, it is mapped to a value in the viewport depth range: vp.minDepth+n.z×(vp.maxDepth−vp.minDepth).</p><p>There is a technical term to describe the values passed into the fragment shader: <a class="link" href="https://gpuweb.github.io/gpuweb/#rasterizationpoint" target="_blank">RasterizationPoint</a>. Keep in mind that despite variable names being the same, there are changes in the data.</p><p>With this in mind, understanding the UV calculation should be straightforward. We map the normalized device coordinate (NDC) range from [-1,1] to [0,1] and flip the y-axis because texture coordinates increase downward. For the z value, we simply read it from clip_position.z.</p><p>Let's go over how to set up this pipeline.</p><p>First, we need an empty canvas to serve as the background. We render from front to back and finally overlay what has been rendered onto the background.</p><p>At the start of each round, we need to clear our destination (dst) texture to (0, 0, 0, 1). This is easily accomplished using the built-in functionality for clearing color attachments, without needing to draw anything. The dst texture serves as the layer zero for our front-to-back alpha blending. The first layer will blend with this texture, the second layer will blend with the resulting texture, and so on. Ultimately, the dst texture will contain all layers composed in the front-to-back order, which is then applied to the background.</p><p>You might wonder why the dst texture is cleared to (0, 0, 0, 1) rather than (0, 0, 0, 0). Shouldn't layer zero be completely transparent? Indeed, the first layer should be fully transparent and have the color (0, 0, 0, 0). However, in front-to-back blending, we use the alpha channel to store (1.0−A_dst) instead of A_dst itself. Therefore, we set the alpha to 1.0 here.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=1218>const renderPassCleanupDesc = {
    colorAttachments: [{
        view: dstTexture.createView(),
        clearValue: { r: 0, g: 0, b: 0, a: 1 },
        loadOp: 'clear',
        storeOp: 'store'
    }]
}
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1267>let passEncoderCleanup = commandEncoder.beginRenderPass(renderPassCleanupDesc);
passEncoderCleanup.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
passEncoderCleanup.end();
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=1217:1224,1266:1268#5_05_transparency">5_05_transparency/index.html:1218-1269 Clean Up the Background</a></div></div><p><div class="img-container"><img class="img" onclick="openImage(this)" src="placeholder.jpg" alt="An Image to Show Individual Layers" sources='[]' /><div class="img-title">An Image to Show Individual Layers</div></div></p><p>For the actual rendering, we define two depth maps for alternating use. During each peeling step, we read depth values from one depth map and write to the other. Since we can't read and write to the same depth map simultaneously, we use two depth maps in an alternating pattern.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=1148>depthAttachment0 = {
    view: depthTexture1.createView(),
    depthClearValue: 1,
    depthLoadOp: 'clear',
    depthStoreOp: 'store'
};

depthAttachment1 = {
    view: depthTexture0.createView(),
    depthClearValue: 1,
    depthLoadOp: 'clear',
    depthStoreOp: 'store'
};
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1205>let colorAttachment0 = {
    view: colorTextureForDebugging.createView(),
    clearValue: { r: 0, g: 0, b: 0, a: 0 },
    loadOp: 'clear',
    storeOp: 'store'
};

let colorAttachment1 = {
    view: colorTextureForDebugging.createView(),
    clearValue: { r: 0, g: 0, b: 0, a: 0 },
    loadOp: 'clear',
    storeOp: 'store'
};
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1226>const renderPassDesc0 = {
    colorAttachments: [colorAttachment0],
    depthStencilAttachment: depthAttachment0
};

const renderPassDesc1 = {
    colorAttachments: [colorAttachment1],
    depthStencilAttachment: depthAttachment1
};
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1270>for (let p = 0; p &lt; 6; ++p) {

    let passEncoder0 = null;
    if (p % 2 == 0) {
        passEncoder0 = commandEncoder.beginRenderPass(renderPassDesc0);
    }
    else {
        passEncoder0 = commandEncoder.beginRenderPass(renderPassDesc1);
    }
    passEncoder0.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
    teapot.encode(passEncoder0, pipeline, p);
    plane.encode(passEncoder0, pipeline, p);
    sphere.encode(passEncoder0, pipeline, p);
    passEncoder0.end();
    let passEncoder1 = commandEncoder.beginRenderPass(renderPassBlend);
    passEncoder1.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
    blender.encode(passEncoder1);
    passEncoder1.end();
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=1147:1159,1204:1216,1225:1233,1269:1287#5_05_transparency">5_05_transparency/index.html:1148-1288 The Actual Rendering Logic</a></div></div><p>At the beginning, we initialize the depth maps to all ones because one is the maximum possible depth value. This ensures that during the first peeling step, we can render the frontmost layer.</p><p>For the color attachment, we always clear it to (0, 0, 0, 0) for front-to-back rendering.</p><p>Notice that we loop the peeling step six times. This hardcoded value means we can peel a maximum of six layers. If there are more layers in the scene, our program won’t be able to handle them. This is a limitation of the current implementation, as we must predetermine the maximum number of supported layers.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="placeholder.jpg" alt="An Image to Show the Rendering Order, Front to Back and Then on the Background" sources='[]' /><div class="img-title">An Image to Show the Rendering Order, Front to Back and Then on the Background</div></div></p><p>After rendering the objects, we call the blender to compose the newly rendered layer onto the existing layer. We will explain the blender in detail later.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=38>struct VertexOutput {
    @builtin(position) clip_position: vec4&lt;f32&gt;,
    @location(0) tex_coords: vec2&lt;f32&gt;
};

@vertex
fn vs_main(
    @location(0) inPos: vec4&lt;f32&gt;
) -&gt; VertexOutput {
    var out: VertexOutput;
    out.clip_position = vec4&lt;f32&gt;(inPos.xy, 0.0, 1.0);
    out.tex_coords = inPos.zw;
    return out;
}

// Fragment shader
@group(0) @binding(0)
var t_src: texture_2d&lt;f32&gt;;
@group(0) @binding(1)
var s: sampler;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    var color:vec4&lt;f32&gt; = textureSample(t_src, s, in.tex_coords);
    return color;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=37:62#5_05_transparency">5_05_transparency/index.html:38-63 Blending Shader</a></div></div><p>The shader is straightforward; it loads a texture (the rendered layer) and applies it to the framebuffer. The crucial part is the alpha blending setup of the pipeline:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=387>const colorState = {
    format: 'bgra8unorm',
    blend: {
        color: {
            operation: "add",
            srcFactor: 'dst-alpha',
            dstFactor: 'one',
        },
        alpha: {
            operation: "add",
            srcFactor: 'zero',
            dstFactor: 'one-minus-src-alpha',
        }
    }
};
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=386:400#5_05_transparency">5_05_transparency/index.html:387-401 Blending Function Setup</a></div></div><p>Note that this uses the same blending equation explained earlier, assuming that the source color is already premultiplied (see the shader for object rendering).</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=1235>const renderPassBlend = {
    colorAttachments: [{
        view: dstTexture.createView(),
        clearValue: { r: 0, g: 0, b: 0, a: 0 },
        loadOp: 'load',
        storeOp: 'store'
    }]
}
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1284>let passEncoder1 = commandEncoder.beginRenderPass(renderPassBlend);
passEncoder1.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
blender.encode(passEncoder1);
passEncoder1.end();
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=1234:1241,1283:1286#5_05_transparency">5_05_transparency/index.html:1235-1287 Render Pass for Blending</a></div></div><p>The above render pass descriptor starts with a cleaned-up destination (dst) texture. Notice that the dst texture was cleared to (0, 0, 0, 1), and from then on, we do not clear the texture anymore. We load it for each blending operation as the texture contains the layers we have already composed.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=68>struct VertexOutput {
    @builtin(position) clip_position: vec4&lt;f32&gt;,
    @location(0) tex_coords: vec2&lt;f32&gt;
};

@vertex
fn vs_main(
    @location(0) inPos: vec4&lt;f32&gt;
) -&gt; VertexOutput {
    var out: VertexOutput;
    out.clip_position = vec4&lt;f32&gt;(inPos.xy, 0.0, 1.0);
    out.tex_coords = inPos.zw;
    return out;
}

// Fragment shader
@group(0) @binding(0)
var t_composed: texture_2d&lt;f32&gt;;
@group(0) @binding(1 )
var s_composed: sampler;

@fragment
fn fs_main(in: VertexOutput) -&gt; @location(0) vec4&lt;f32&gt; {
    return textureSample(t_composed, s_composed, in.tex_coords);
}
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=262>const colorState = {
    format: 'bgra8unorm',
    blend: {
        alpha: {
            operation: "add",
            srcFactor: 'one',
            dstFactor: 'one-minus-src-alpha',
        },
        color: {
            operation: "add",
            srcFactor: 'one',
            dstFactor: 'one-minus-src-alpha',
        }
    }
};
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1289>let finalEncoder = commandEncoder.beginRenderPass(renderPassFinal);
final.encode(finalEncoder);
finalEncoder.end();
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=67:91,261:275,1288:1290#5_05_transparency">5_05_transparency/index.html:68-1291 Final Step</a></div></div><p>Finally, in the last step, we render the composed layers onto a black background using back-to-front blending. Since our color is premultiplied, we use the C_src +(1−A_src)*C_dst formula.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_depth_peeling_result.png" original_src="depth_peeling_result.png" alt="Depth Peeling Result" sources='[]' /><div class="img-title">Depth Peeling Result</div></div></p>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/WebGPUUnleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
</body>

</html>