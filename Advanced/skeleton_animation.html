<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/webgpuunleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/webgpuunleashed/Advanced/skeleton_animation.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/webgpuunleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/webgpuunleashed/Advanced/skeleton_animation.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/webgpuunleashed/meta.png" />

    <link rel="stylesheet" href="/webgpuunleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/cpp.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/webgpuunleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/webgpuunleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/webgpuunleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/webgpuunleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/webgpuunleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/webgpuunleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/webgpuunleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/webgpuunleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/webgpuunleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/webgpuunleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/webgpuunleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/webgpuunleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/webgpuunleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/webgpuunleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/webgpuunleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/webgpuunleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/webgpuunleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/webgpuunleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/webgpuunleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/webgpuunleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/webgpuunleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/webgpuunleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/webgpuunleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/webgpuunleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/webgpuunleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/webgpuunleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/webgpuunleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/webgpuunleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/webgpuunleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/webgpuunleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/webgpuunleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >5.6 Skeleton Animation</h2><p>So far, we have learned how to animate rigid objects by updating their model-view matrices. In this tutorial, we will explore how to create skeleton animations for animating characters like animals and human figures. Unlike rigid objects, these models deform during animation.</p><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html#5_06_skeleton_animation" target="_blank" class="comment"><svg style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
                    width="32" fill="#dadadb" viewBox="0 -960 960 960"><path d="M189-160q-60 0-102.5-43T42-307q0-9 1-18t3-18l84-336q14-54 57-87.5t98-33.5h390q55 0 98 33.5t57 87.5l84 336q2 9 3.5 18.5T919-306q0 61-43.5 103.5T771-160q-42 0-78-22t-54-60l-28-58q-5-10-15-15t-21-5H385q-11 0-21 5t-15 15l-28 58q-18 38-54 60t-78 22Zm3-80q19 0 34.5-10t23.5-27l28-57q15-31 44-48.5t63-17.5h190q34 0 63 18t45 48l28 57q8 17 23.5 27t34.5 10q28 0 48-18.5t21-46.5q0 1-2-19l-84-335q-7-27-28-44t-49-17H285q-28 0-49.5 17T208-659l-84 335q-2 6-2 18 0 28 20.5 47t49.5 19Zm348-280q17 0 28.5-11.5T580-560q0-17-11.5-28.5T540-600q-17 0-28.5 11.5T500-560q0 17 11.5 28.5T540-520Zm80-80q17 0 28.5-11.5T660-640q0-17-11.5-28.5T620-680q-17 0-28.5 11.5T580-640q0 17 11.5 28.5T620-600Zm0 160q17 0 28.5-11.5T660-480q0-17-11.5-28.5T620-520q-17 0-28.5 11.5T580-480q0 17 11.5 28.5T620-440Zm80-80q17 0 28.5-11.5T740-560q0-17-11.5-28.5T700-600q-17 0-28.5 11.5T660-560q0 17 11.5 28.5T700-520Zm-360 60q13 0 21.5-8.5T370-490v-40h40q13 0 21.5-8.5T440-560q0-13-8.5-21.5T410-590h-40v-40q0-13-8.5-21.5T340-660q-13 0-21.5 8.5T310-630v40h-40q-13 0-21.5 8.5T240-560q0 13 8.5 21.5T270-530h40v40q0 13 8.5 21.5T340-460Zm140-20Z"/></svg>Launch Playground - 5_06_skeleton_animation</a><p>Fundamentally, any animation can be achieved by directly updating vertex positions. However, this approach requires substantial storage for vertex data, making it impractical for real-time use. Skeleton animation, inspired by natural systems, defines a simplified structure—a skeleton—consisting of rigid parts called bones connected by joints that can be rotated. The actual vertices of the 3D model are attached to these bones.</p><p>Bones are organized hierarchically, with the spine as the root, limbs as branches, and fingers as twigs. Consequently, updating a root bone affects all attached child bones, making animation intuitive.</p><p>To determine the actual rotation and translation of a bone, we must recursively apply transformations from the root to the end bone.</p><p>Each bone influences the vertices based on its influence factor, where a value of zero means no influence. Once the transformations for each bone are decided, we update the vertices by applying these bone transformations scaled by their respective influences.</p><p>Now, let’s discuss implementing skeleton animation. The first step is to create an animated asset. I followed a simple tutorial in Blender for this purpose. Once the animation is complete, we need to export it to a file. Note that not all 3D file formats support animation; for instance, the OBJ file format does not. In this example, we will use the DAE file format. As in previous tutorials, our focus is not on implementing a file parser; instead, we will use an existing format parser and convert the necessary data into JSON for loading in JavaScript. This time, the preprocessing will be done in C++, as our DAE file parser is written in C++.</p><div class="code-fragments"><pre><code class="language-cpp code-block" startNumber=1>#include &lt;iostream&gt;
#include &lt;assimp/Importer.hpp&gt;
#include &lt;assimp/scene.h&gt;
#include &lt;assimp/postprocess.h&gt;
#include &lt;fstream&gt;
#include &lt;unordered_map&gt;

struct Bone
{
    aiBone *bone;
    aiNodeAnim *ani;
};

void printHierarchy(std::ofstream &amp;outputFile, aiNode *node, int indentation,
                    std::unordered_map&lt;std::string, Bone&gt; &amp;bones, int &amp;boneId, bool isRoot)
{
    std::cout &lt;&lt; std::string(indentation, '-') &lt;&lt; node-&gt;mName.C_Str() &lt;&lt; std::endl;

    const std::string boneName = std::string(node-&gt;mName.C_Str());

    if (bones.find(boneName) != bones.end())
    {
        std::cout &lt;&lt; "bone = = " &lt;&lt; boneName &lt;&lt; std::endl;
        outputFile &lt;&lt; "{\"id\":" &lt;&lt; (boneId++) &lt;&lt; ",\"nodeTransform\":[" &lt;&lt; std::endl;

        outputFile &lt;&lt; node-&gt;mTransformation[0][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][3] &lt;&lt; std::endl;

        outputFile &lt;&lt; "],\"name\":\"" &lt;&lt; node-&gt;mName.C_Str() &lt;&lt; "\",\"children\":[" &lt;&lt; std::endl;

        for (int i = 0; i &lt; node-&gt;mNumChildren; ++i)
        {
            printHierarchy(outputFile, node-&gt;mChildren[i], indentation + 1, bones, boneId, false);

            if (i &lt; node-&gt;mNumChildren - 1)
            {
                outputFile &lt;&lt; "," &lt;&lt; std::endl;
            }
        }

        outputFile &lt;&lt; "]" &lt;&lt; std::endl;

        aiBone *b = bones[boneName].bone;
        outputFile &lt;&lt; ", \"offsetMatrix\":[";
        for (int i = 0; i &lt; 4; ++i)
        {
            auto w = b-&gt;mOffsetMatrix[i];
            outputFile &lt;&lt; w[0] &lt;&lt; "," &lt;&lt; w[1] &lt;&lt; "," &lt;&lt; w[2] &lt;&lt; "," &lt;&lt; w[3];
            if (i &lt; 3)
            {
                outputFile &lt;&lt; ",";
            }
        }
        outputFile &lt;&lt; "],\n \"weights\":[" &lt;&lt; std::endl;

        for (int i = 0; i &lt; b-&gt;mNumWeights; ++i)
        {
            outputFile &lt;&lt; "{\"id\":" &lt;&lt; b-&gt;mWeights[i].mVertexId &lt;&lt; ",\"w\":" &lt;&lt; b-&gt;mWeights[i].mWeight &lt;&lt; "}";
            if (i &lt; b-&gt;mNumWeights - 1)
            {
                outputFile &lt;&lt; "," &lt;&lt; std::endl;
            }
        }
        outputFile &lt;&lt; "]";

        aiNodeAnim *ani = bones[boneName].ani;

        if (ani)
        {

            outputFile &lt;&lt; ",\"ani\":{" &lt;&lt; std::endl;

            if (ani-&gt;mNumPositionKeys &gt; 0)
            {
                outputFile &lt;&lt; "\"pos\":[";

                for (int e = 0; e &lt; ani-&gt;mNumPositionKeys; ++e)
                {
                    auto pk = ani-&gt;mPositionKeys[e];
                    outputFile &lt;&lt; "{\"time\":" &lt;&lt; pk.mTime &lt;&lt; ",\"pos\":[" &lt;&lt; pk.mValue[0] &lt;&lt; "," &lt;&lt; pk.mValue[1] &lt;&lt; "," &lt;&lt; pk.mValue[2] &lt;&lt; "]}" &lt;&lt; std::endl;
                    if (e &lt; ani-&gt;mNumPositionKeys - 1)
                    {
                        outputFile &lt;&lt; ",";
                    }
                }

                outputFile &lt;&lt; "]" &lt;&lt; std::endl;
            }

            if (ani-&gt;mNumRotationKeys &gt; 0)
            {
                outputFile &lt;&lt; ",\"rot\":[";

                for (int e = 0; e &lt; ani-&gt;mNumRotationKeys; ++e)
                {
                    auto rk = ani-&gt;mRotationKeys[e];
                    outputFile &lt;&lt; "{\"time\":" &lt;&lt; rk.mTime &lt;&lt; ",\"q\":[" &lt;&lt; rk.mValue.w &lt;&lt; "," &lt;&lt; rk.mValue.x &lt;&lt; "," &lt;&lt; rk.mValue.y &lt;&lt; "," &lt;&lt; rk.mValue.z &lt;&lt; "]}" &lt;&lt; std::endl;
                    if (e &lt; ani-&gt;mNumRotationKeys - 1)
                    {
                        outputFile &lt;&lt; ",";
                    }
                }

                outputFile &lt;&lt; "]" &lt;&lt; std::endl;
            }

            if (ani-&gt;mNumScalingKeys &gt; 0)
            {
                outputFile &lt;&lt; ",\"scal\":[";

                for (int e = 0; e &lt; ani-&gt;mNumScalingKeys; ++e)
                {
                    auto sk = ani-&gt;mScalingKeys[e];
                    outputFile &lt;&lt; "{\"time\":" &lt;&lt; sk.mTime &lt;&lt; ",\"pos\":[" &lt;&lt; sk.mValue[0] &lt;&lt; "," &lt;&lt; sk.mValue[1] &lt;&lt; "," &lt;&lt; sk.mValue[2] &lt;&lt; "]}" &lt;&lt; std::endl;
                    if (e &lt; ani-&gt;mNumScalingKeys - 1)
                    {
                        outputFile &lt;&lt; ",";
                    }
                }

                outputFile &lt;&lt; "]" &lt;&lt; std::endl;
            }

            outputFile &lt;&lt; "}" &lt;&lt; std::endl;
        }
        outputFile &lt;&lt; "}";
    }
    else
    {
        if (isRoot)
        {
            outputFile &lt;&lt; "{\"name\":\"" &lt;&lt; node-&gt;mName.C_Str() &lt;&lt; "\",\"nodeTransform\":[" &lt;&lt; 1 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 1 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 1 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 0 &lt;&lt; "," &lt;&lt; 1 &lt;&lt; std::endl;
        }
        else
        {
            outputFile &lt;&lt; "{\"name\":\"" &lt;&lt; node-&gt;mName.C_Str() &lt;&lt; "\",\"nodeTransform\":[" &lt;&lt; node-&gt;mTransformation[0][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[0][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[1][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[2][3] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][0] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][1] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][2] &lt;&lt; "," &lt;&lt; node-&gt;mTransformation[3][3] &lt;&lt; std::endl;
        }
        outputFile &lt;&lt; "],\"children\":[" &lt;&lt; std::endl;
        for (int i = 0; i &lt; node-&gt;mNumChildren; ++i)
        {
            printHierarchy(outputFile, node-&gt;mChildren[i], indentation + 1, bones, boneId, false);

            if (i &lt; node-&gt;mNumChildren - 1)
            {
                outputFile &lt;&lt; "," &lt;&lt; std::endl;
            }
        }

        outputFile &lt;&lt; "]}";
    }
}

int main()
{
    std::cout &lt;&lt; "test" &lt;&lt; std::endl;
    const char *path = "../../../data/cuberun.dae";
    Assimp::Importer importer;
    const aiScene *scene = importer.ReadFile(path, aiProcess_Triangulate | aiProcess_FlipUVs);
    if (!scene || scene-&gt;mFlags &amp; AI_SCENE_FLAGS_INCOMPLETE || !scene-&gt;mRootNode)
    {
        std::cout &lt;&lt; "ERROR::ASSIMP::" &lt;&lt; importer.GetErrorString() &lt;&lt; std::endl;
        return 1;
    }

    std::cout &lt;&lt; "mesh count " &lt;&lt; scene-&gt;mNumMeshes &lt;&lt; std::endl;

    const aiMesh *mesh = scene-&gt;mMeshes[0];

    std::cout &lt;&lt; "mesh uv channel " &lt;&lt; mesh-&gt;GetNumUVChannels() &lt;&lt; std::endl;

    // std::cout &lt;&lt; "children count " &lt;&lt; scene-&gt;mRootNode-&gt;mChildren[0]-&gt;mNumChildren &lt;&lt; std::endl;

    std::ofstream outputFile;
    outputFile.open("cuberun.json");
    outputFile &lt;&lt; "{\"vert\":[";

    for (unsigned int i = 0; i &lt; mesh-&gt;mNumVertices; i++)
    {
        outputFile &lt;&lt; mesh-&gt;mVertices[i][0] &lt;&lt; ", " &lt;&lt; mesh-&gt;mVertices[i][1] &lt;&lt; ", " &lt;&lt; mesh-&gt;mVertices[i][2] &lt;&lt; ", ";
        outputFile &lt;&lt; mesh-&gt;mNormals[i][0] &lt;&lt; ", " &lt;&lt; mesh-&gt;mNormals[i][1] &lt;&lt; ", " &lt;&lt; mesh-&gt;mNormals[i][2];
        if (i != mesh-&gt;mNumVertices - 1)
        {
            outputFile &lt;&lt; ", " &lt;&lt; std::endl;
        }
    }
    outputFile &lt;&lt; "],\"indices\":[\n";

    for (unsigned int i = 0; i &lt; mesh-&gt;mNumFaces; ++i)
    {
        aiFace face = mesh-&gt;mFaces[i];

        // std::cout &lt;&lt; "face ";
        for (unsigned int f = 0; f &lt; face.mNumIndices; ++f)
        {
            outputFile &lt;&lt; face.mIndices[f];
            if (i != mesh-&gt;mNumFaces - 1 || f != face.mNumIndices - 1)
            {
                outputFile &lt;&lt; ", ";
            }
        }
        outputFile &lt;&lt; std::endl;
    }
    outputFile &lt;&lt; "],\"skeleton\":[\n";

    std::unordered_map&lt;std::string, Bone&gt; bones;

    if (mesh-&gt;HasBones())
    {
        for (int i = 0; i &lt; mesh-&gt;mNumBones; ++i)
        {
            bones[std::string(mesh-&gt;mBones[i]-&gt;mName.C_Str())] = {mesh-&gt;mBones[i], nullptr};
            // std::cout &lt;&lt; "insert bone " &lt;&lt; mesh-&gt;mBones[i]-&gt;mName.C_Str() &lt;&lt; std::endl;
        }
        std::cout &lt;&lt; "animation size " &lt;&lt; scene-&gt;mNumAnimations &lt;&lt; std::endl;

        aiAnimation *ani = scene-&gt;mAnimations[0];

        std::cout &lt;&lt; "channel size" &lt;&lt; ani-&gt;mNumChannels &lt;&lt; std::endl;

        for (int i = 0; i &lt; ani-&gt;mNumChannels; ++i)
        {
            aiNodeAnim *a = ani-&gt;mChannels[i];
            std::string boneName = std::string(a-&gt;mNodeName.C_Str());
            if (bones.find(boneName) != bones.end())
            {
                bones[boneName].ani = a;
            }
        }
    }
    int boneId = 0;
    printHierarchy(outputFile, scene-&gt;mRootNode, 0, bones, boneId, true);

    outputFile &lt;&lt; "]}";

    outputFile.close();

    /*
        std::cout &lt;&lt; "has tex " &lt;&lt; mesh-&gt;HasTextureCoords(0) &lt;&lt; std::endl;

        std::cout &lt;&lt; "has bone " &lt;&lt; mesh-&gt;HasBones() &lt;&lt; std::endl;

        std::cout &lt;&lt; "bones " &lt;&lt; mesh-&gt;mNumBones &lt;&lt; std::endl;
*/

    return 0;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=0:244#5_06_skeleton_animation/preprocess">5_06_skeleton_animation/preprocess/main.cpp:1-245 DAE Preprocessor</a></div></div><p>The library we use to parse the DAE file is called Assimp. This versatile tool can handle various common 3D formats. Assimp organizes 3D objects into a scene structure. For our demo file, which contains only one mesh, we retrieve mesh zero. We then need to extract the geometry data, which includes vertices, vertex normals, and triangle meshes, similar to the process used for OBJ files.</p><p>Our main focus is on extracting the bones and animations. The scene structure contains a list of bones, each with a unique name, and an animation list. Since we have only one animation, there is just one animation object. This animation object has multiple channels, each associated with a bone. A channel includes a node name that corresponds to the associated bone. Using this information, we can map bones to their respective animations.</p><p>The scene structure organizes objects hierarchically, a common approach in computer graphics. For instance, in a 3D model of a car, the wheels are children of the car body. In a scene with multiple car models, the scene itself is the root node, with each car as a child node. Parts and accessories, such as wheels and doors, are children of the car nodes. This hierarchy allows transformations applied to a parent node to automatically affect all its children. For example, moving the car also moves its wheels and doors. Thus, when calculating the transformation of a leaf node, we must account for all transformations accumulated from the scene root.</p><p>In our demo scene, although there is only one object, the bones are also organized hierarchically. Consequently, moving the shoulder will affect the forearm and fingers.</p><p>In the second part of data extraction, we need to dump this hierarchical structure. We start with the scene root, which, although not a 3D object itself, represents the scene. Since the scene root has no transformation, we assign it an identity matrix. For the remaining nodes, we determine if a node is a bone or part of the 3D mesh. If it is a mesh, we save its transformation. If it is a bone, we save its offset matrix, weights, and animations.</p><p>The offset matrix is specific to bones and provides additional positional information. The weights are tuples for each vertex, where the first element is the vertex ID and the second element is the influence number.</p><p>For animations, we extract a sequence of transformations. The sequence length corresponds to the number of keyframes, each with a timestamp and three types of transformations: translation, rotation, and scaling. Translation and scaling are represented as vectors, while rotation is represented as quaternions.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=853>let boneWeights = new Float32Array(this.objBody.vert.length * 16 / 3);

function assignBoneWeightsToVerticesHelper(bone) {

    if (bone.weights) {
        for (let i = 0; i &lt; bone.weights.length; ++i) {
            const { id, w } = bone.weights[i];
            boneWeights[id * 16 + bone.id] = w;
        }
    }

    if (bone.children) {
        if (bone.children.length &gt; 0) {
            for (let i = 0; i &lt; bone.children.length; ++i) {
                assignBoneWeightsToVerticesHelper(bone.children[i]);
            }
        }
    }
}

for (let i = 0; i &lt; this.objBody.skeleton.length; ++i) {
    assignBoneWeightsToVerticesHelper(this.objBody.skeleton[i]);
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=852:874#5_06_skeleton_animation">5_06_skeleton_animation/index.html:853-875 Gather Bone Weights</a></div></div><p>The first step in processing the file is to create a flattened vertex bone weight array. Since we have 16 bones, including the root scene, each vertex will be associated with 16 float values. Although there are actually 13 bones, we round up to the nearest multiple of four for alignment reasons, which will be explained later. Given that bones are organized in a hierarchical tree structure, a helper function is used to recursively visit all bone nodes.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=664>updateAnimation(time) {
    let boneTransforms = new Float32Array(16 * 16);

    function interpolatedV(time, V, interpolate) {

        time = time % V[V.length - 1].time;
        /*  while (time &gt; V[V.length - 1].time) {
              time -= V[V.length - 1].time;
          }*/

        let firstIndex = -1;

        for (; firstIndex &lt; V.length - 1; ++firstIndex) {
           // const i = (firstIndex + V.length) % V.length;
           // console.log(i,firstIndex)
            if (time &lt; V[firstIndex + 1].time) {
                break;
            }
        }

        const secondIndex = firstIndex + 1;

        let startTime = 0;
        let endTime = V[secondIndex].time;

        if (firstIndex == -1) {
            firstIndex = V.length - 1;
        }
        else {
            startTime = V[firstIndex].time;
        }

        const factor = (time - startTime) / (endTime - startTime);

        return interpolate(V[firstIndex], V[secondIndex], factor);
    }


    function deriveBoneTransformHelper(bone, parentTransform) {
        if (bone.id !== undefined) {
            const offsetMatrix = glMatrix.mat4.fromValues(
                bone.offsetMatrix[0],
                bone.offsetMatrix[4],
                bone.offsetMatrix[8],
                bone.offsetMatrix[12],
                bone.offsetMatrix[1],
                bone.offsetMatrix[5],
                bone.offsetMatrix[9],
                bone.offsetMatrix[13],
                bone.offsetMatrix[2],
                bone.offsetMatrix[6],
                bone.offsetMatrix[10],
                bone.offsetMatrix[14],
                bone.offsetMatrix[3],
                bone.offsetMatrix[7],
                bone.offsetMatrix[11],
                bone.offsetMatrix[15]);
            if (bone.ani) {

                const interpolatedPos = interpolatedV(time, bone.ani.pos, (pos1, pos2, factor) =&gt; {
                    return glMatrix.vec3.lerp(glMatrix.vec3.create(), glMatrix.vec3.fromValues(pos1.pos[0], pos1.pos[1], pos1.pos[2]),
                        glMatrix.vec3.fromValues(pos2.pos[0], pos2.pos[1], pos2.pos[2]), factor);
                });
                const translationMatrix = glMatrix.mat4.fromTranslation(glMatrix.mat4.create(),
                    interpolatedPos);

                const interpolatedQuat = interpolatedV(time, bone.ani.rot, (quat1, quat2, factor) =&gt; {
                    return glMatrix.quat.lerp(glMatrix.quat.create(),
                        glMatrix.quat.fromValues(quat1.q[1], quat1.q[2], quat1.q[3], quat1.q[0]),
                        glMatrix.quat.fromValues(quat2.q[1], quat2.q[2], quat2.q[3], quat2.q[0]),
                        factor
                    );
                });

                const rotationMatrix = glMatrix.mat4.fromQuat(glMatrix.mat4.create(), interpolatedQuat);

                const interpolatedScale = interpolatedV(time, bone.ani.scal, (scal1, scal2, factor) =&gt; {
                    return glMatrix.vec3.lerp(glMatrix.vec3.create(), glMatrix.vec3.fromValues(scal1.pos[0], scal1.pos[1], scal1.pos[2]),
                        glMatrix.vec3.fromValues(scal2.pos[0], scal2.pos[1], scal2.pos[2]), factor);
                });

                const scalingMatrix = glMatrix.mat4.fromScaling(glMatrix.mat4.create(), interpolatedScale);

                const rotation_x_scale = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                    rotationMatrix, scalingMatrix);

                const locationTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                    translationMatrix, rotation_x_scale);

                const globalTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                    parentTransform, locationTransformation);

                const finalBoneTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                    globalTransformation, offsetMatrix);

                boneTransforms.set(finalBoneTransformation, bone.id * 16);
                /*
                                        console.log("bone transform ", bone.name, finalBoneTransformation);
                                        console.log("node trans", locationTransformation);
                                        console.log("parent", parentTransform);*/

                if (bone.children.length &gt; 0) {
                    for (let i = 0; i &lt; bone.children.length; ++i) {
                        deriveBoneTransformHelper(bone.children[i], globalTransformation);
                    }
                }
            }
            else {
                const nodeTransform = glMatrix.mat4.fromValues(bone.nodeTransform[0],
                    bone.nodeTransform[4],
                    bone.nodeTransform[8],
                    bone.nodeTransform[12],
                    bone.nodeTransform[1],
                    bone.nodeTransform[5],
                    bone.nodeTransform[9],
                    bone.nodeTransform[13],
                    bone.nodeTransform[2],
                    bone.nodeTransform[6],
                    bone.nodeTransform[10],
                    bone.nodeTransform[14],
                    bone.nodeTransform[3],
                    bone.nodeTransform[7],
                    bone.nodeTransform[11],
                    bone.nodeTransform[15]);

                const bt = glMatrix.mat4.multiply(glMatrix.mat4.create(), parentTransform, nodeTransform);
                const bt2 = glMatrix.mat4.multiply(glMatrix.mat4.create(), bt, offsetMatrix);
                boneTransforms.set(bt2, bone.id * 16);
                /* console.log("= bone transform ", bone.name, bt2);
                 console.log("= bone nodeTransform", nodeTransform);
                 console.log("global ", bt);*/

                if (bone.children.length &gt; 0) {
                    for (let i = 0; i &lt; bone.children.length; ++i) {
                        deriveBoneTransformHelper(bone.children[i], bt);
                    }
                }
            }
        }

        else {

            const nodeTransform = glMatrix.mat4.fromValues(bone.nodeTransform[0],
                bone.nodeTransform[4],
                bone.nodeTransform[8],
                bone.nodeTransform[12],
                bone.nodeTransform[1],
                bone.nodeTransform[5],
                bone.nodeTransform[9],
                bone.nodeTransform[13],
                bone.nodeTransform[2],
                bone.nodeTransform[6],
                bone.nodeTransform[10],
                bone.nodeTransform[14],
                bone.nodeTransform[3],
                bone.nodeTransform[7],
                bone.nodeTransform[11],
                bone.nodeTransform[15]);

            const globalTransformation = glMatrix.mat4.multiply(glMatrix.mat4.create(),
                parentTransform, nodeTransform);

            // console.log("* bone transform ", bone.name, globalTransformation);

            if (bone.children.length &gt; 0) {
                for (let i = 0; i &lt; bone.children.length; ++i) {
                    deriveBoneTransformHelper(bone.children[i], globalTransformation);
                }
            }
        }
    }

    for (let i = 0; i &lt; this.objBody.skeleton.length; ++i) {
        deriveBoneTransformHelper(this.objBody.skeleton[i], glMatrix.mat4.identity(glMatrix.mat4.create()));
    }

    //console.log("bone transformation", boneTransforms);
    return boneTransforms;

}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=663:842#5_06_skeleton_animation">5_06_skeleton_animation/index.html:664-843 Given a Timestamp, Return the Current Bone Transformations</a></div></div><p>Next, we examine a helper function designed to return the current bone transformations given a specific timestamp. This function retrieves all necessary transformations for each bone, including local translation, rotation, and scaling, as well as accumulated transformations from its parent and the offset matrix. Since the requested timestamp may not correspond to a keyframe, interpolation is performed to compute the appropriate transformation. The function then recursively processes all child bones. The result is a flattened transformation array for all bones, which is passed as a uniform to the shader.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=162>@group(0) @binding(0)
var&lt;uniform&gt; modelView: mat4x4&lt;f32&gt;;
@group(0) @binding(1)
var&lt;uniform&gt; projection: mat4x4&lt;f32&gt;;
@group(0) @binding(2)
var&lt;uniform&gt; normalMatrix: mat4x4&lt;f32&gt;;
@group(0) @binding(3) 
var&lt;uniform&gt; lightDirection: vec3&lt;f32&gt;;
@group(0) @binding(4)
var&lt;uniform&gt; viewDirection: vec3&lt;f32&gt;;

@group(0) @binding(5)
var&lt;uniform&gt; ambientColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(0.15, 0.10, 0.10, 1.0);
@group(0) @binding(6)
var&lt;uniform&gt; diffuseColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(0.55, 0.55, 0.55, 1.0);
@group(0) @binding(7)
var&lt;uniform&gt; specularColor:vec4&lt;f32&gt;;// = vec4&lt;f32&gt;(1.0, 1.0, 1.0, 1.0);

@group(0) @binding(8)
var&lt;uniform&gt; shininess:f32;// = 20.0;

@group(1) @binding(0)
var&lt;uniform&gt; boneTransforms: array&lt;mat4x4&lt;f32&gt;, 16&gt;;
    
const diffuseConstant:f32 = 1.0;
const specularConstant:f32 = 1.0;
const ambientConstant: f32 = 1.0;

fn specular(lightDir:vec3&lt;f32&gt;, viewDir:vec3&lt;f32&gt;, normal:vec3&lt;f32&gt;,  specularColor:vec3&lt;f32&gt;, 
     shininess:f32) -&gt; vec3&lt;f32&gt; {
    let reflectDir:vec3&lt;f32&gt; = reflect(-lightDir, normal);
    let specDot:f32 = max(dot(reflectDir, viewDir), 0.0);
    return pow(specDot, shininess) * specularColor;
}

fn diffuse(lightDir:vec3&lt;f32&gt;, normal:vec3&lt;f32&gt;,  diffuseColor:vec3&lt;f32&gt;) -&gt; vec3&lt;f32&gt;{
    return max(dot(lightDir, normal), 0.0) * diffuseColor;
}

struct VertexOutput {
    @builtin(position) clip_position: vec4&lt;f32&gt;,
    @location(0) viewDir: vec3&lt;f32&gt;,
    @location(1) normal: vec3&lt;f32&gt;,
    @location(2) lightDir: vec3&lt;f32&gt;,
    @location(3) wldLoc: vec3&lt;f32&gt;,
    @location(4) lightLoc: vec3&lt;f32&gt;,
    @location(5) inPos: vec3&lt;f32&gt;
};

@vertex
fn vs_main(
    @location(0) inPos: vec3&lt;f32&gt;,
    @location(1) inNormal: vec3&lt;f32&gt;,
    @location(2) boneWeight0: vec4&lt;f32&gt;,
    @location(3) boneWeight1: vec4&lt;f32&gt;,
    @location(4) boneWeight2: vec4&lt;f32&gt;,
    @location(5) boneWeight3: vec4&lt;f32&gt;
) -&gt; VertexOutput {
    var out: VertexOutput;
    var totalTransform:mat4x4&lt;f32&gt; = mat4x4&lt;f32&gt;(0.0,0.0,0.0,0.0,
        0.0,0.0,0.0,0.0,
        0.0,0.0,0.0,0.0,
        0.0,0.0,0.0,0.0);
    
        totalTransform += boneTransforms[0]  * boneWeight0[0];
        totalTransform += boneTransforms[1] * boneWeight0[1];
        totalTransform += boneTransforms[2]* boneWeight0[2];
        totalTransform += boneTransforms[3] * boneWeight0[3];
        totalTransform += boneTransforms[4] * boneWeight1[0];
        totalTransform += boneTransforms[5] * boneWeight1[1];
        totalTransform += boneTransforms[6] * boneWeight1[2];
        totalTransform += boneTransforms[7] * boneWeight1[3];
        totalTransform += boneTransforms[8] * boneWeight2[0];
        totalTransform += boneTransforms[9] * boneWeight2[1];
        totalTransform += boneTransforms[10]* boneWeight2[2];
        totalTransform += boneTransforms[11] * boneWeight2[3];
        totalTransform += boneTransforms[12] * boneWeight3[0];


    out.viewDir = normalize((normalMatrix * vec4&lt;f32&gt;(-viewDirection, 0.0)).xyz);
    out.lightDir = normalize((normalMatrix * vec4&lt;f32&gt;(-lightDirection, 0.0)).xyz);
    out.normal = normalize(normalMatrix * totalTransform * vec4&lt;f32&gt;(inNormal, 0.0)).xyz;  
    var wldLoc:vec4&lt;f32&gt; = modelView *totalTransform *vec4(inPos,1.0);
    out.clip_position = projection * wldLoc;
    out.wldLoc = wldLoc.xyz / wldLoc.w;
    out.inPos = (totalTransform *vec4(inPos,1.0)).xyz;
    var lightLoc:vec4&lt;f32&gt; = modelView * vec4&lt;f32&gt;(lightDirection, 1.0);
    out.lightLoc = lightLoc.xyz / lightLoc.w;

    return out;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=161:251#5_06_skeleton_animation">5_06_skeleton_animation/index.html:162-252 Animation Shader</a></div></div><p>The shader used here is an adaptation of the shadow map shader, with modifications primarily in the vertex shader. We pass two additional pieces of information: the bone transformations as a uniform containing the current animation frame's bone transformations, and the bone weights as vertex attributes. Since vertex attributes cannot directly handle large data like matrices, we decompose the weights into four vectors, each holding four float values. This necessitates rounding the number of bones to 16 for alignment.</p><p>In the vertex shader, we calculate a weighted sum of the bone transformations based on the bone weights. This computed transformation is then applied to the vertex, followed by the model-view matrix and the projection matrix, as previously.</p><p>It’s important to note that we assign a dedicated group ID to the bone transformation uniform. This is because the bone transformations are updated frequently, so separating them from other, more stable uniforms helps optimize performance.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=881>this.boneWeightBuffer = createGPUBuffer(device, boneWeights, GPUBufferUsage.VERTEX);
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1126>const boneWeight0AttribDesc = {
    shaderLocation: 2,
    offset: 0,
    format: 'float32x4'
};

const boneWeight1AttribDesc = {
    shaderLocation: 3,
    offset: 4 * 4,
    format: 'float32x4'
};

const boneWeight2AttribDesc = {
    shaderLocation: 4,
    offset: 4 * 8,
    format: 'float32x4'
};

const boneWeight3AttribDesc = {
    shaderLocation: 5,
    offset: 4 * 12,
    format: 'float32x4'
};

const boneWeightBufferLayoutDesc = {
    attributes: [boneWeight0AttribDesc, boneWeight1AttribDesc, boneWeight2AttribDesc, boneWeight3AttribDesc],
    arrayStride: 4 * 16,
    stepMode: 'vertex'
};
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1161>const pipelineDesc = {
    layout,
    vertex: {
        module: shaderModule,
        entryPoint: 'vs_main',
        buffers: [positionBufferLayoutDesc,
            normalBufferLayoutDesc,
            boneWeightBufferLayoutDesc]
    },
    fragment: {
        module: shaderModule,
        entryPoint: 'fs_main',
        targets: [colorState]
    },
    primitive: {
        topology: 'triangle-list',
        frontFace: 'ccw',
        cullMode: 'none'
    },
    depthStencil: {
        depthWriteEnabled: true,
        depthCompare: 'less',
        format: 'depth32float'
    }
};
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=880:880,1125:1153,1160:1184#5_06_skeleton_animation">5_06_skeleton_animation/index.html:881-1185 Setup the Bone Weight Buffer</a></div></div><p>Next, let’s look at how to set up the bone weight buffer. We have already created the flattened bone weight array; now, we use this array to populate four vertex attributes that store the bone weights.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=1464>if (!startTime) {
    startTime = timestamp;
}
const elapsed = timestamp - startTime;
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1474>const boneTransforms = runCube.updateAnimation(elapsed);
let boneTransformBufferUpdate = createGPUBuffer(device, boneTransforms, GPUBufferUsage.COPY_SRC);
</pre></code><div class="code-fragments-separator">• • •</div><pre><code class="language-javascript code-block" startNumber=1566>commandEncoder.copyBufferToBuffer(boneTransformBufferUpdate, 0,
    runCube.boneTransformUniformBuffer, 0, boneTransforms.byteLength);
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html?highlight=1463:1466,1473:1474,1565:1566#5_06_skeleton_animation">5_06_skeleton_animation/index.html:1464-1567 Animation Update in the Render Loop</a></div></div><p>Finally, let's examine how animation transforms are updated. For each frame, we measure the elapsed time, use this to compute the current bone transformations, and then load these transformations into the uniform buffer. This ensures that the animation remains fluid and up-to-date as the scene progresses.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_skeleton_animation.png" original_src="skeleton_animation.png" alt="Rendering Result" sources='[]' /><div class="img-title">Rendering Result</div></div></p>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/webgpuunleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/webgpuunleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/WebGPUUnleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G278P1YSJ6"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag() { dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'G-G278P1YSJ6');
</script>
</body>

</html>