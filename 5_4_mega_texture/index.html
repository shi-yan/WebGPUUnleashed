<html>

<head>
    <style>
        html {
            position: relative;
            height: 100%;
        }

        body {
            margin: 0px;
            position: relative;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480"></canvas>
</body>
<script src="../utils/gl-matrix.js">
    //https://www.renaudpradenc.com/?tag=megatexture
    //https://publications.lib.chalmers.se/records/fulltext/155126.pdf
    //http://holger.dammertz.org/stuff/notes_VirtualTexturing.html
    //https://silverspaceship.com/src/svt/
    //https://webbtelescope.org/contents/media/images/2023/137/01HBBMDH12APPEGB8DXVVEP8XA?news=true
</script>
<script src="../utils/utils.js"></script>
<script id="tile_visibility_shader" type="wgsl">
// Vertex shader

@group(0) @binding(0)
var<uniform> transform: mat4x4<f32>;
@group(0) @binding(1)
var<uniform> projection: mat4x4<f32>;

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex:vec2<f32>,
    @location(1) @interpolate(flat) tile:vec2<u32>,
    @location(2) tex2:vec2<f32>,
};

@vertex
fn vs_main(
    @location(0) inPos: vec4<f32>,
    @location(1) loc: vec2<u32>
) -> VertexOutput {
    var out: VertexOutput;
    out.tile = loc;
    out.tex = inPos.zw ;
    out.tex2 = inPos.zw + vec2<f32>(loc);
    out.clip_position = projection * transform * vec4<f32>(inPos.xy + vec2<f32>(loc)*256.0, 0.0, 1.0);
    return out;
}

// Fragment shader
@group(0)
@binding(2)
var<uniform> level_tile_count: array<vec4<u32>, 8>; //must align to 16bytes
@group(0)
@binding(3)
var<storage,read_write> visible_tiles: array<u32>;
@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    var dx:vec2<f32> = dpdxFine(in.tex * 256.0);
    var dy:vec2<f32> = dpdyFine(in.tex * 256.0);
    var d:f32 = max(dot(dx, dx), dot(dy, dy));
    var level:f32 = max(f32(floor(0.5*log2(d))),0.0);

    /*if ( level > 0.01 || level < -0.01) {
        return vec4(1.0,1.0,1.0,1.0);
    }*/

    var edge_size:f32 =  pow(2, level) * 256.0;

    var x:f32 = (f32(in.tile.x) * 256.0 + in.tex.x*256.0) / edge_size;
    var y:f32 = (f32(in.tile.y) * 256.0 + in.tex.y*256.0) / edge_size;

    var base:i32 = 0;
    if (level - 1 >= 0) {
        for(var i:i32 = 0;i<i32(level-1);i+=1){
            base += i32(level_tile_count[i].x);
        }
    }
    base = i32(floor(x)); // + floor(y)*f32(level_tile_count[i32(level)].x));
    visible_tiles[base] = 1;
    //return vec4(f32(in.tile.x)/255.0,f32(in.tile.y)/255.0,level ,1.0);

    /*if( (in.tile.x + in.tile.y) % 2 == 0) {
        return vec4(1.0,1.0,1.0,1.0);
    }*/
    return vec4(level ,0.0,0.0,1.0);
}

</script>

<script>
    const imageWidth = 10752;
    const imageHeight = 9216;

    const tileH = Math.ceil(imageWidth / 256);
    const tileV = Math.ceil(imageHeight / 256);
    class Tile {
        constructor() {
            this.pipeline = null;
            this.uniformBindGroup = null;
            this.tileLocBuffer = null;
            this.tileVisibilityBuffer = null;
            this.tileVisibilityBufferRead = null;
            this.overallTileCount = 0;
        }

        async setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer) {

            let code = document.getElementById('tile_visibility_shader').innerText;

            const shaderDesc = { code: code };
            let shaderModule = device.createShaderModule(shaderDesc);

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x4'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 4, // sizeof(float) * 4
                stepMode: 'vertex'
            };

            const positions = new Float32Array([
                256.0, 0.0, 1.0, 0.0,
                256.0, 256.0, 1.0, 1.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 256.0, 0.0, 1.0
            ]);

            this.positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);

            let tiles = [];

            for (let y = 0; y < tileV; ++y) {
                for (let x = 0; x < tileH; ++x) {
                    tiles.push(x);
                    tiles.push(y);
                }
            }

            const tileLocAttribDesc = {
                shaderLocation: 1, // @location(0)
                offset: 0,
                format: 'uint32x2'
            };

            const tileLocBufferLayoutDesc = {
                attributes: [tileLocAttribDesc],
                arrayStride: 4 * 2, // sizeof(int) * 3
                stepMode: 'instance'
            };

            this.tileLocBuffer = createGPUBuffer(device, new Uint32Array(tiles), GPUBufferUsage.VERTEX);

            let levelTileCount = [
                42 * 36, 0, 0, 0,
                21 * 18, 0, 0, 0,
                11 * 9, 0, 0, 0,
                6 * 5, 0, 0, 0,
                3 * 3, 0, 0, 0,
                2 * 2, 0, 0, 0,
                1, 0, 0, 0,
                1, 0, 0, 0,
                1, 0, 0, 0,
            ];

            for (let i = 0; i < 9; ++i) {
                this.overallTileCount += levelTileCount[i * 4];
            }

            this.overallTileCount = Math.ceil(this.overallTileCount * 0.25) * 4  // must be 4 bytes aligned for buffer copy

            levelTileCount = createGPUBuffer(device, new Uint32Array(levelTileCount), GPUBufferUsage.UNIFORM);

            console.log("tile count ", this.overallTileCount);

            this.tileVisibilityBuffer = createGPUBuffer(device, new Uint32Array(this.overallTileCount), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC);
            this.tileVisibilityBufferRead = createGPUBuffer(device, new Uint32Array(this.overallTileCount), GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);

            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: { type: "storage" }
                    }
                ]
            });

            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: translateMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: levelTileCount
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: this.tileVisibilityBuffer
                        }
                    }
                ]
            });

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, tileLocBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-strip',
                    frontFace: 'ccw',
                    cullMode: 'none'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);
        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.tileLocBuffer);
            encoder.draw(4, tileH * tileV);
        }
    }


    async function webgpu() {

        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        let device = await adapter.requestDevice();
        console.log(device);

        let context = configContext(device, canvas);

        let translateMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
            glMatrix.vec3.fromValues(0, 0, 10), glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(0.0, 1.0, 0.0));

        let orthProjMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), -320.0, 320.0, 240.0, -240.0, -1000.0, 1000.0);

        let translateMatrixUniformBuffer = createGPUBuffer(device, translateMatrix, GPUBufferUsage.UNIFORM);

        let projectionMatrixUniformBuffer = createGPUBuffer(device, orthProjMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let tile = new Tile();
        await tile.setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer);

        let updatedProjectionMatrix = null;
        render = async () => {

            let projectionMatrixUniformBufferUpdate = null;

            let colorTexture = context.getCurrentTexture();
            let colorTextureView = colorTexture.createView();

            let colorAttachment = {
                view: colorTextureView,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
            };

            const renderPassDesc = {
                colorAttachments: [colorAttachment]
            };
            const commandEncoder = device.createCommandEncoder();

            if (updatedProjectionMatrix) {
                projectionMatrixUniformBufferUpdate = createGPUBuffer(device, updatedProjectionMatrix, GPUBufferUsage.COPY_SRC);

                commandEncoder.copyBufferToBuffer(projectionMatrixUniformBufferUpdate, 0,
                    projectionMatrixUniformBuffer, 0, updatedProjectionMatrix.byteLength);
            }
            const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);

            passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            tile.encode(passEncoder);
            passEncoder.end();
            commandEncoder.copyBufferToBuffer(tile.tileVisibilityBuffer, 0,
                tile.tileVisibilityBufferRead, 0, tile.overallTileCount);
            device.queue.submit([commandEncoder.finish()]);
            await device.queue.onSubmittedWorkDone();

            await tile.tileVisibilityBufferRead.mapAsync(GPUMapMode.READ, 0, tile.overallTileCount*4);

            let vb = tile.tileVisibilityBufferRead.getMappedRange(0, tile.overallTileCount*4);

            if (projectionMatrixUniformBufferUpdate) {
                projectionMatrixUniformBufferUpdate.destroy();
                updatedProjectionMatrix = null;
            }

            console.log(new Uint32Array(vb));
            tile.tileVisibilityBufferRead.unmap();

            requestAnimationFrame(render);

        }

        requestAnimationFrame(render);

        let isDragging = false;
        let prevX = 0;
        let prevY = 0;
        let pivotX = 0;
        let pivotY = 0;
        let scale = 1.0;

        canvas.onmousedown = (e) => {
            isDragging = true;
            var rect = canvas.getBoundingClientRect();
            prevX = event.clientX - rect.left;
            prevY = event.clientY - rect.top;
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onmousemove = (e) => {
            if (isDragging) {
                var rect = canvas.getBoundingClientRect();
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;

                let deltaX = prevX - x;
                let deltaY = prevY - y;

                pivotX += deltaX * scale;
                pivotY += deltaY * scale;

                updatedProjectionMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), pivotX - 320.0 * scale, pivotX + 320.0 * scale, pivotY + 240.0 * scale, pivotY - 240.0 * scale, -1000.0, 1000.0);

                prevX = x;
                prevY = y;
                //requestAnimationFrame(render);
            }
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onmouseup = (e) => {
            isDragging = false;
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onwheel = (e) => {
            scale += e.deltaY * 0.01
            if (scale < 0.01) {
                scale = 0.01;
            }
            else if (scale > 100.0) {
                scale = 100.0;
            }

            console.log(scale);
            e.preventDefault();
            e.stopPropagation();

            updatedProjectionMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), pivotX - 320.0 * scale, pivotX + 320.0 * scale, pivotY + 240.0 * scale, pivotY - 240.0 * scale, -1000.0, 1000.0);

        }
    }

    webgpu();
</script>

</html>