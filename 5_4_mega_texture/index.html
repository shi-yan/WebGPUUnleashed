<html>

<head>
    <style>
        html {
            position: relative;
            height: 100%;
        }

        body {
            margin: 0px;
            position: relative;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480" style="width:100%;height:100%"></canvas>
</body>
<script src="../utils/gl-matrix.js">
    //https://www.renaudpradenc.com/?tag=megatexture
    //https://publications.lib.chalmers.se/records/fulltext/155126.pdf
    //http://holger.dammertz.org/stuff/notes_VirtualTexturing.html
    //https://silverspaceship.com/src/svt/
    //https://webbtelescope.org/contents/media/images/2023/137/01HBBMDH12APPEGB8DXVVEP8XA?news=true
</script>
<script src="../utils/utils.js"></script>
<script id="tile_visibility_shader" type="wgsl">
// Vertex shader

@group(0) @binding(0)
var<uniform> transform: mat4x4<f32>;
@group(0) @binding(1)
var<uniform> projection: mat4x4<f32>;

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>
};

@vertex
fn vs_main(
    @location(0) inPos: vec3<f32>,
    @location(1) loc: vec2<u32>
) -> VertexOutput {
    var out: VertexOutput;
    out.clip_position = projection * transform * vec4<f32>(inPos.xy + vec2<f32>(loc)*256.0, inPos.z, 1.0);
    return out;
}

// Fragment shader

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    return vec4(0.0,0.0,1.0,1.0);
}

</script>

<script>
    const imageWidth = 10752;
    const imageHeight = 9216;

    const tileH = Math.ceil(imageWidth / 256);
    const tileV = Math.ceil(imageHeight / 256);
    class Tile {
        constructor() {
            this.pipeline = null;
            this.uniformBindGroup = null;
            this.tileLocBuffer = null;
        }

        async setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer) {

            let code = document.getElementById('tile_visibility_shader').innerText;

            const shaderDesc = { code: code };
            let shaderModule = device.createShaderModule(shaderDesc);

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x3'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 3, // sizeof(float) * 3
                stepMode: 'vertex'
            };

            const positions = new Float32Array([
                256.0, 0.0, 0.0,
                256.0, 256.0, 0.0,
                0.0, 0.0, 0.0,
                0.0, 256.0, 0.0
            ]);

            this.positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);




            let tiles = [];

            for (let y = 0; y < tileV; ++y) {
                for (let x = 0; x < tileH; ++x) {
                    tiles.push(x);
                    tiles.push(y);
                }
            }

            const tileLocAttribDesc = {
                shaderLocation: 1, // @location(0)
                offset: 0,
                format: 'uint32x2'
            };

            const tileLocBufferLayoutDesc = {
                attributes: [tileLocAttribDesc],
                arrayStride: 4 * 2, // sizeof(int) * 3
                stepMode: 'instance'
            };

            this.tileLocBuffer = createGPUBuffer(device, new Uint32Array(tiles), GPUBufferUsage.VERTEX);


            let uniformBindGroupLayout = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    }
                ]
            });

            this.uniformBindGroup = device.createBindGroup({
                layout: uniformBindGroupLayout,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: translateMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    }
                ]
            });

            const pipelineLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayout] };
            const layout = device.createPipelineLayout(pipelineLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const pipelineDesc = {
                layout,
                vertex: {
                    module: shaderModule,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, tileLocBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModule,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-strip',
                    frontFace: 'ccw',
                    cullMode: 'none'
                }
            };

            this.pipeline = device.createRenderPipeline(pipelineDesc);

        }

        encode(encoder) {
            encoder.setPipeline(this.pipeline);
            encoder.setBindGroup(0, this.uniformBindGroup);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.tileLocBuffer);
            encoder.draw(4, tileH * tileV);
        }
    }


    async function webgpu() {

        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        let device = await adapter.requestDevice();
        console.log(device);

        let context = configContext(device, canvas);

        let translateMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
            glMatrix.vec3.fromValues(0, 0, 10), glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(0.0, 1.0, 0.0));

        let orthProjMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), -320.0, 320.0, 240.0, -240.0, -1000.0, 1000.0);

        let translateMatrixUniformBuffer = createGPUBuffer(device, translateMatrix, GPUBufferUsage.UNIFORM);

        let projectionMatrixUniformBuffer = createGPUBuffer(device, orthProjMatrix, GPUBufferUsage.UNIFORM);

        let tile = new Tile();
        await tile.setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer);

        let colorTexture = context.getCurrentTexture();
        let colorTextureView = colorTexture.createView();

        let colorAttachment = {
            view: colorTextureView,
            clearValue: { r: 1, g: 0, b: 0, a: 1 },
            loadOp: 'clear',
            storeOp: 'store'
        };

        const renderPassDesc = {
            colorAttachments: [colorAttachment]
        };
        commandEncoder = device.createCommandEncoder();

        passEncoder = commandEncoder.beginRenderPass(renderPassDesc);
        passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
        tile.encode(passEncoder);
        passEncoder.end();

        device.queue.submit([commandEncoder.finish()]);
    }

    webgpu();
</script>

</html>