<html>

<head>
    <style>
        html {
            position: relative;
            height: 100%;
        }

        body {
            margin: 0px;
            position: relative;
            height: 100%;
        }
    </style>
</head>

<body>
    <canvas id="canvas" width="640" height="480"></canvas>
</body>
<script src="../utils/gl-matrix.js">
    //https://www.renaudpradenc.com/?tag=megatexture
    //https://publications.lib.chalmers.se/records/fulltext/155126.pdf
    //http://holger.dammertz.org/stuff/notes_VirtualTexturing.html
    //https://silverspaceship.com/src/svt/
    //https://webbtelescope.org/contents/media/images/2023/137/01HBBMDH12APPEGB8DXVVEP8XA?news=true
</script>
<script src="../utils/utils.js">
    //talk about debugging
</script>
<script id="tile_visibility_shader" type="wgsl">
// Vertex shader

@group(0) @binding(0)
var<uniform> transform: mat4x4<f32>;
@group(0) @binding(1)
var<uniform> projection: mat4x4<f32>;

struct VertexOutput {
    @builtin(position) clip_position: vec4<f32>,
    @location(0) tex:vec2<f32>,
    @location(1) @interpolate(flat) tile:vec2<u32>
};

@vertex
fn vs_main(
    @location(0) inPos: vec4<f32>,
    @location(1) loc: vec2<u32>
) -> VertexOutput {
    var out: VertexOutput;
    out.tile = loc;
    out.tex = inPos.zw ;
    out.clip_position = projection * transform * vec4<f32>(inPos.xy + vec2<f32>(loc)*256.0, 0.0, 1.0);
    return out;
}

// Fragment shader
@group(0)
@binding(2)
var<uniform> level_tile_count: array<vec4<u32>, 8>; //must align to 16bytes
@group(0)
@binding(3)
var<storage,read_write> visible_tiles: array<u32>;
@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    var dx:vec2<f32> = dpdxFine(in.tex * 256.0);
    var dy:vec2<f32> = dpdyFine(in.tex * 256.0);
    var d:f32 = max(dot(dx, dx), dot(dy, dy));
    var level:f32 = max(f32(floor(0.5*log2(d))),0.0);

    var edge_size:f32 =  pow(2, level) * 256.0;

    var x:f32 = (f32(in.tile.x) * 256.0 + in.tex.x*256.0) / edge_size;
    var y:f32 = (f32(in.tile.y) * 256.0 + in.tex.y*256.0) / edge_size;

    var base:i32 = 0;
    if (level - 1 >= 0) {
        for(var i:i32 = 0;i<i32(level-1);i+=1){
            base += i32(level_tile_count[i].x * level_tile_count[i].y);
        }
    }
    base = i32(floor(x) + floor(y)*f32(level_tile_count[i32(level)].x));
    visible_tiles[base] = 1;
    /*if (visible_tiles[0] < u32(base)) {
        visible_tiles[0] = u32(base);
    }*/
    //return vec4(f32(in.tile.x)/255.0,f32(in.tile.y)/255.0,level ,1.0);

    discard;
    return vec4<f32>(1.0, 0.0, 0.0, 1.0);

}

</script>

<script id="tile_shader" type="wgsl">
    // Vertex shader
    
    @group(0) @binding(0)
    var<uniform> transform: mat4x4<f32>;
    @group(0) @binding(1)
    var<uniform> projection: mat4x4<f32>;
    
    struct VertexOutput {
        @builtin(position) clip_position: vec4<f32>,
        @location(0) tex:vec2<f32>,
        @location(1) @interpolate(flat) tile:vec2<u32>
    };
    
    @vertex
    fn vs_main(
        @location(0) inPos: vec4<f32>,
        @location(1) loc: vec2<u32>
    ) -> VertexOutput {
        var out: VertexOutput;
        out.tile = loc;
        out.tex = inPos.zw ;
        out.clip_position = projection * transform * vec4<f32>(inPos.xy + vec2<f32>(loc)*256.0, 0.0, 1.0);
        return out;
    }
    
    // Fragment shader
    @group(0)
    @binding(2)
    var<uniform> level_tile_count: array<vec4<u32>, 8>; //must align to 16bytes
    @group(0)
    @binding(3)
    var<storage,read> hash: array<vec2<f32> >;
    @group(0) @binding(4)
    var t_diffuse: texture_2d<f32>;
    @group(0) @binding(5)
    var s_diffuse: sampler;

    @fragment
    fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
        var dx:vec2<f32> = dpdxFine(in.tex * 256.0);
        var dy:vec2<f32> = dpdyFine(in.tex * 256.0);
        var d:f32 = max(dot(dx, dx), dot(dy, dy));
        var level:f32 = max(f32(floor(0.5*log2(d))),0.0);
    
        var edge_size:f32 =  pow(2, level) * 256.0;
    
        var x:f32 = (f32(in.tile.x) * 256.0 + in.tex.x*256.0) / edge_size;
        var y:f32 = (f32(in.tile.y) * 256.0 + in.tex.y*256.0) / edge_size;
    
        var base:i32 = 0;
        if (level - 1 >= 0) {
            for(var i:i32 = 0;i<i32(level-1);i+=1){
                base += i32(level_tile_count[i].x * level_tile_count[i].y);
            }
        }
        base = i32(floor(x) + floor(y)*f32(level_tile_count[i32(level)].x));

        return textureSampleLevel(t_diffuse, s_diffuse, hash[base] + in.tex *256.0 / 1024.0, 0);
    }
    
    </script>

<script>


    const imageWidth = 10752;
    const imageHeight = 9216;
    const tileSize = 256;
    const textureSize = 1024;
    const visibleTileCountOnTexture = textureSize * textureSize / (tileSize * tileSize);
    const levelCount = Math.log2(256) + 1;

    const tileH = Math.ceil(imageWidth / tileSize);
    const tileV = Math.ceil(imageHeight / tileSize);

    class KeyIdManager {

        constructor() {
            this.used = new Map();
            this.available = [];

            for (let i = 0; i < visibleTileCountOnTexture; ++i) {
                this.available.push(i);
            }
        }

        async generate(keys, loadTileIntoTexture) {
            let newUsed = new Map();
            let result = [];

            //1. gather tiles that should be visible for the next round
            let keySet = new Set();
            for (let k of keys) {
                keySet.add(k);
            }

            //2. eliminate tiles that are not visible this round but was visible in the previous round, by
            // adding them into the available array
            for (const [uk, uv] of this.used) {
                if (!keySet.has(uk)) {
                    this.available.push(uv);
                }
            }

            //3. for all visible tiles
            for (let k of keys) {
                // if this tile was visible before, skip updating texture map
                if (this.used.has(k)) {
                    const id = this.used.get(k);
                    newUsed.set(k, id);
                    result.push({ key: k, id });
                }
                else {
                    const id = this.available.shift();
                    newUsed.set(k, id);
                    result.push({ key: k, id });
                    const level = 0;
                    const x = k % 42;
                    const y = Math.floor(k / 42);
                    await loadTileIntoTexture( x, y, level, k, id);
                }
            }
            this.used = newUsed;
            return result;
        }
    }

    let levelTileCount = [
        42, 36, 0, 0,
        21, 18, 0, 0,
        11, 9, 0, 0,
        6, 5, 0, 0,
        3, 5, 0, 0,
        2, 5, 0, 0,
        1, 0, 0, 0,
        1, 0, 0, 0,
        1, 0, 0, 0,
    ];

    let overallTileCount = 0;

    for (let i = 0; i < 9; ++i) {
        overallTileCount += levelTileCount[i * 4] * levelTileCount[i * 4 + 1];
    }

    overallTileCount = Math.ceil(overallTileCount * 0.25) * 4  // must be 4 bytes aligned for buffer copy

    console.log("overalltilecount", overallTileCount);

    function key(width, height, x, y, level) {
        let base = 0;
        let tileH = 0;
        let tileV = 0;
        for (let i = 0; i < level; ++i) {
            tileH = Math.ceil(width / (256 * Math.pow(2, level)));
            tileV = Math.ceil(height / (256 * Math.pow(2, level)));
            base += tileH * tileV;
        }

        return y * tileH + x + base;
    }

    function allTileCount(width, height, level) {
        let base = 0;
        let tileH = 0;
        let tileV = 0;
        for (let i = 0; i < level; ++i) {
            tileH = Math.ceil(width / (256 * Math.pow(2, level)));
            tileV = Math.ceil(height / (256 * Math.pow(2, level)));
            base += tileH * tileV;
        }
        return base;
    }

    async function downloadTexture(device, texture, width, height) {
        const bufferWidth = Math.ceil(width / 256.0) * 256;
        const copiedBuffer = createGPUBuffer(device, new Uint8Array(bufferWidth * height * 4), GPUBufferUsage.COPY_DST | GPUBufferUsage.MAP_READ);

        const commandEncoder = device.createCommandEncoder();
        commandEncoder.copyTextureToBuffer({ texture: texture, origin: { x: 0, y: 0 } }, { buffer: copiedBuffer, bytesPerRow: bufferWidth * 4 }, { width: width, height: height });
        device.queue.submit([commandEncoder.finish()]);

        await device.queue.onSubmittedWorkDone();

        await copiedBuffer.mapAsync(GPUMapMode.READ, 0, bufferWidth * height * 4);

        const x = new Uint8ClampedArray(copiedBuffer.getMappedRange());
        const imageData = new ImageData(x, 1024, 1024);
        imagedataToImage(imageData);

        copiedBuffer.unmap();

        copiedBuffer.destroy();
    }

    class VisibleTileHashTable {
        constructor() {
            this.table = new Float32Array(allTileCount() * 2);
            this.texture = null;
            this.tileTexCoordBuffer = null;
            this.tileTexCoordBufferUpdate = null;
            this.keyIdManager = new KeyIdManager();
        }

        setup(device) {

            const textureDesc = {
                size: [1024, 1024, 1],
                dimension: '2d',
                format: 'bgra8unorm',
                usage: GPUTextureUsage.RENDER_ATTACHMENT | GPUTextureUsage.TEXTURE_BINDING | GPUTextureUsage.COPY_DST | GPUTextureUsage.COPY_SRC
            };
            this.texture = device.createTexture(textureDesc);
            this.tileTexCoordBuffer = createGPUBuffer(device, new Float32Array(overallTileCount * 2), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_DST);
            this.tileTexCoordBufferUpdate = createGPUBuffer(device, new Float32Array(overallTileCount * 2), GPUBufferUsage.COPY_SRC | GPUBufferUsage.MAP_WRITE);
        }

        async loadTileIntoTexture(device, bufferUpdate, imageWidth, imageHeight, x, y, level, tileKey, id) {
            //  console.log("id",x,y,level,id)
            this.table.set(tileKey * 2, [0.25 * (id % 4), 0.25 * Math.floor(id / 4)]);

            const writeArray = new Float32Array(bufferUpdate.getMappedRange(tileKey * 2 * 4, 8));
            writeArray.set([0.25 * (id % 4), 0.25 * Math.floor(id / 4)]);

            const url = '../crab_nebula/crab_' + level + '_' + y + '_' + x + '.png';

            const response = await fetch(url);
            const blob = await response.blob();
            const imgBitmap = await createImageBitmap(blob);
            //  console.log({ x: 256 * (id % 4), y: 256 * Math.floor(id / 4) });
            device.queue.copyExternalImageToTexture({ source: imgBitmap }, {
                texture: this.texture,
                origin: { x: 256 * (id % 4), y: 256 * Math.floor(id / 4) }
            }, { width: 256, height: 256 });
        }

        async assembleTexture(device, imageWidth, imageHeight, tiles) {
            await this.tileTexCoordBufferUpdate.mapAsync(GPUMapMode.WRITE, 0, overallTileCount * 2 * 4);

            tiles = await this.keyIdManager.generate(tiles, async ( x, y, level, k, id) => {
                await this.loadTileIntoTexture(device, this.tileTexCoordBufferUpdate, imageWidth, imageHeight,  x, y, level, k, id);
            });

            console.log(tiles);

            this.tileTexCoordBufferUpdate.unmap();
        }
    }

    class Tile {
        constructor() {
            this.visibilityPipeline = null;
            this.tilePipeline = null;
            this.uniformBindGroupVisibility = null;
            this.tileLocBuffer = null;
            this.tileVisibilityBufferZeros = null;
            this.tileVisibilityBuffer = null;
            this.tileVisibilityBufferRead = null;
        }

        async setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer, tileTexCoordBuffer, assembledTexture) {

            let codeVisibility = document.getElementById('tile_visibility_shader').innerText;

            const shaderDescVisibility = { code: codeVisibility };
            let shaderModuleVisibility = device.createShaderModule(shaderDescVisibility);

            let codeTile = document.getElementById('tile_shader').innerText;

            const shaderDescTile = { code: codeTile };
            let shaderModuleTile = device.createShaderModule(shaderDescTile);

            const positionAttribDesc = {
                shaderLocation: 0, // @location(0)
                offset: 0,
                format: 'float32x4'
            };

            const positionBufferLayoutDesc = {
                attributes: [positionAttribDesc],
                arrayStride: 4 * 4, // sizeof(float) * 4
                stepMode: 'vertex'
            };

            const positions = new Float32Array([
                256.0, 0.0, 1.0, 0.0,
                256.0, 256.0, 1.0, 1.0,
                0.0, 0.0, 0.0, 0.0,
                0.0, 256.0, 0.0, 1.0
            ]);

            this.positionBuffer = createGPUBuffer(device, positions, GPUBufferUsage.VERTEX);

            let tiles = [];

            for (let y = 0; y < tileV; ++y) {
                for (let x = 0; x < tileH; ++x) {
                    tiles.push(x);
                    tiles.push(y);
                }
            }

            const tileLocAttribDesc = {
                shaderLocation: 1, // @location(0)
                offset: 0,
                format: 'uint32x2'
            };

            const tileLocBufferLayoutDesc = {
                attributes: [tileLocAttribDesc],
                arrayStride: 4 * 2, // sizeof(int) * 3
                stepMode: 'instance'
            };

            this.tileLocBuffer = createGPUBuffer(device, new Uint32Array(tiles), GPUBufferUsage.VERTEX);

            const levelTileCountBuffer = createGPUBuffer(device, new Uint32Array(levelTileCount), GPUBufferUsage.UNIFORM);

            this.tileVisibilityBufferZeros = createGPUBuffer(device, new Uint32Array(overallTileCount), GPUBufferUsage.COPY_SRC);
            this.tileVisibilityBuffer = createGPUBuffer(device, new Uint32Array(overallTileCount), GPUBufferUsage.STORAGE | GPUBufferUsage.COPY_SRC | GPUBufferUsage.COPY_DST);
            this.tileVisibilityBufferRead = createGPUBuffer(device, new Uint32Array(overallTileCount), GPUBufferUsage.MAP_READ | GPUBufferUsage.COPY_DST);

            let uniformBindGroupLayoutVisibility = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: { type: "storage" }
                    }
                ]
            });

            this.uniformBindGroupVisibility = device.createBindGroup({
                layout: uniformBindGroupLayoutVisibility,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: translateMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: levelTileCountBuffer
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: this.tileVisibilityBuffer
                        }
                    }
                ]
            });

            let uniformBindGroupLayoutTile = device.createBindGroupLayout({
                entries: [
                    {
                        binding: 0,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 1,
                        visibility: GPUShaderStage.VERTEX,
                        buffer: {}
                    },
                    {
                        binding: 2,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: {}
                    },
                    {
                        binding: 3,
                        visibility: GPUShaderStage.FRAGMENT,
                        buffer: { type: "read-only-storage" }
                    },
                    {
                        binding: 4,
                        visibility: GPUShaderStage.FRAGMENT,
                        texture: {}
                    },
                    {
                        binding: 5,
                        visibility: GPUShaderStage.FRAGMENT,
                        sampler: {}
                    }
                ]
            });
            const sampler = device.createSampler({
                addressModeU: 'clamp-to-edge',
                addressModeV: 'clamp-to-edge',
                magFilter: 'linear',
                minFilter: 'linear',
                mipmapFilter: 'linear'
            });
            this.uniformBindGroupTile = device.createBindGroup({
                layout: uniformBindGroupLayoutTile,
                entries: [
                    {
                        binding: 0,
                        resource: {
                            buffer: translateMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 1,
                        resource: {
                            buffer: projectionMatrixUniformBuffer
                        }
                    },
                    {
                        binding: 2,
                        resource: {
                            buffer: levelTileCountBuffer
                        }
                    },
                    {
                        binding: 3,
                        resource: {
                            buffer: tileTexCoordBuffer
                        }
                    },
                    {
                        binding: 4,
                        resource: assembledTexture.createView()
                    },
                    {
                        binding: 5,
                        resource:
                            sampler
                    }
                ]
            });

            const pipelineVisibilityLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayoutVisibility] };
            const visibilityLayout = device.createPipelineLayout(pipelineVisibilityLayoutDesc);

            const colorState = {
                format: 'bgra8unorm'
            };

            const visibilityPipelineDesc = {
                layout: visibilityLayout,
                vertex: {
                    module: shaderModuleVisibility,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, tileLocBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModuleVisibility,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-strip',
                    frontFace: 'ccw',
                    cullMode: 'none'
                }
            };

            this.visibilityPipeline = device.createRenderPipeline(visibilityPipelineDesc);

            const pipelineTileLayoutDesc = { bindGroupLayouts: [uniformBindGroupLayoutTile] };
            const tileLayout = device.createPipelineLayout(pipelineTileLayoutDesc);

            const tilePipelineDesc = {
                layout: tileLayout,
                vertex: {
                    module: shaderModuleTile,
                    entryPoint: 'vs_main',
                    buffers: [positionBufferLayoutDesc, tileLocBufferLayoutDesc]
                },
                fragment: {
                    module: shaderModuleTile,
                    entryPoint: 'fs_main',
                    targets: [colorState]
                },
                primitive: {
                    topology: 'triangle-strip',
                    frontFace: 'ccw',
                    cullMode: 'none'
                }
            };

            this.tilePipeline = device.createRenderPipeline(tilePipelineDesc);
        }

        encodeVisibility(encoder) {
            encoder.setPipeline(this.visibilityPipeline);
            encoder.setBindGroup(0, this.uniformBindGroupVisibility);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.tileLocBuffer);
            encoder.draw(4, tileH * tileV);
        }

        encodeTile(encoder) {
            encoder.setPipeline(this.tilePipeline);
            encoder.setBindGroup(0, this.uniformBindGroupTile);
            encoder.setVertexBuffer(0, this.positionBuffer);
            encoder.setVertexBuffer(1, this.tileLocBuffer);
            encoder.draw(4, tileH * tileV);
        }
    }

    async function webgpu() {
        const adapter = await navigator.gpu.requestAdapter();
        console.log(adapter);

        let device = await adapter.requestDevice();
        console.log(device);

        let context = configContext(device, canvas);

        let translateMatrix = glMatrix.mat4.lookAt(glMatrix.mat4.create(),
            glMatrix.vec3.fromValues(0, 0, 10), glMatrix.vec3.fromValues(0, 0, 0), glMatrix.vec3.fromValues(0.0, 1.0, 0.0));

        let orthProjMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), -320.0, 320.0, 240.0, -240.0, -1000.0, 1000.0);

        let translateMatrixUniformBuffer = createGPUBuffer(device, translateMatrix, GPUBufferUsage.UNIFORM);

        let projectionMatrixUniformBuffer = createGPUBuffer(device, orthProjMatrix, GPUBufferUsage.UNIFORM | GPUBufferUsage.COPY_DST);

        let visibleTiles = new VisibleTileHashTable();
        visibleTiles.setup(device);

        let tile = new Tile();
        await tile.setup(device, translateMatrixUniformBuffer, projectionMatrixUniformBuffer, visibleTiles.tileTexCoordBuffer, visibleTiles.texture);

        const colorTextureForVisibilityDesc = {
            size: [canvas.width, canvas.height, 1],
            dimension: '2d',
            format: 'bgra8unorm',
            usage: GPUTextureUsage.RENDER_ATTACHMENT
        };
        let colorTextureForVisibility = device.createTexture(colorTextureForVisibilityDesc);

        let updatedProjectionMatrix = null;
        let hasDumped = false;
        render = async () => {

            let projectionMatrixUniformBufferUpdate = null;

            let colorAttachment = {
                view: colorTextureForVisibility.createView(),
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'discard'
            };

            const renderPassDesc = {
                colorAttachments: [colorAttachment]
            };
            const commandEncoder = device.createCommandEncoder();

            if (updatedProjectionMatrix) {
                projectionMatrixUniformBufferUpdate = createGPUBuffer(device, updatedProjectionMatrix, GPUBufferUsage.COPY_SRC);

                commandEncoder.copyBufferToBuffer(projectionMatrixUniformBufferUpdate, 0,
                    projectionMatrixUniformBuffer, 0, updatedProjectionMatrix.byteLength);
            }
            commandEncoder.copyBufferToBuffer(tile.tileVisibilityBufferZeros, 0,
                tile.tileVisibilityBuffer, 0, overallTileCount * 4);
            const passEncoder = commandEncoder.beginRenderPass(renderPassDesc);

            passEncoder.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            tile.encodeVisibility(passEncoder);
            passEncoder.end();
            commandEncoder.copyBufferToBuffer(tile.tileVisibilityBuffer, 0,
                tile.tileVisibilityBufferRead, 0, overallTileCount * 4);
            device.queue.submit([commandEncoder.finish()]);
            await device.queue.onSubmittedWorkDone();

            await tile.tileVisibilityBufferRead.mapAsync(GPUMapMode.READ, 0, overallTileCount * 4);

            let vb = tile.tileVisibilityBufferRead.getMappedRange(0, overallTileCount * 4);

            if (projectionMatrixUniformBufferUpdate) {
                projectionMatrixUniformBufferUpdate.destroy();
                updatedProjectionMatrix = null;
            }

            vb = new Uint32Array(vb);
            console.log("debug oversize ", vb[0])
            let vt = [];
            for (let i = 0; i < 42 * 36; ++i) {
                if (vb[i] == 1) {
                    vt.push(i);
                }
            }
            tile.tileVisibilityBufferRead.unmap();
            await visibleTiles.assembleTexture(device, imageWidth,
                imageHeight, vt);
            /*if (!hasDumped) {
                await downloadTexture(device, visibleTiles.texture, 1024, 1024);
            }*/

            const commandEncoder2 = device.createCommandEncoder();

            commandEncoder2.copyBufferToBuffer(visibleTiles.tileTexCoordBufferUpdate, 0,
                visibleTiles.tileTexCoordBuffer, 0, overallTileCount * 2 * 4);

            let colorTexture2 = context.getCurrentTexture();
            let colorTextureView2 = colorTexture2.createView();

            let colorAttachment2 = {
                view: colorTextureView2,
                clearValue: { r: 1, g: 0, b: 0, a: 1 },
                loadOp: 'clear',
                storeOp: 'store'
            };
            const renderPassDesc2 = {
                colorAttachments: [colorAttachment2]
            };
            const passEncoder2 = commandEncoder2.beginRenderPass(renderPassDesc2);

            passEncoder2.setViewport(0, 0, canvas.width, canvas.height, 0, 1);
            tile.encodeTile(passEncoder2);
            passEncoder2.end();

            device.queue.submit([commandEncoder2.finish()]);

            await device.queue.onSubmittedWorkDone();

            requestAnimationFrame(render);
        }

        requestAnimationFrame(render);

        let isDragging = false;
        let prevX = 0;
        let prevY = 0;
        let pivotX = 0;
        let pivotY = 0;
        let scale = 1.0;

        canvas.onmousedown = (e) => {
            isDragging = true;
            var rect = canvas.getBoundingClientRect();
            prevX = event.clientX - rect.left;
            prevY = event.clientY - rect.top;
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onmousemove = (e) => {
            if (isDragging) {
                var rect = canvas.getBoundingClientRect();
                x = event.clientX - rect.left;
                y = event.clientY - rect.top;

                let deltaX = prevX - x;
                let deltaY = prevY - y;

                pivotX += deltaX * scale;
                pivotY += deltaY * scale;

                updatedProjectionMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), pivotX - 320.0 * scale, pivotX + 320.0 * scale, pivotY + 240.0 * scale, pivotY - 240.0 * scale, -1000.0, 1000.0);

                prevX = x;
                prevY = y;
                //requestAnimationFrame(render);
            }
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onmouseup = (e) => {
            isDragging = false;
            e.preventDefault();
            e.stopPropagation();
        }

        canvas.onwheel = (e) => {
            scale += e.deltaY * 0.01
            if (scale < 0.01) {
                scale = 0.01;
            }
            else if (scale > 100.0) {
                scale = 100.0;
            }

            console.log(scale);
            e.preventDefault();
            e.stopPropagation();

            updatedProjectionMatrix = glMatrix.mat4.ortho(glMatrix.mat4.create(), pivotX - 320.0 * scale, pivotX + 320.0 * scale, pivotY + 240.0 * scale, pivotY - 240.0 * scale, -1000.0, 1000.0);

        }
    }

    webgpu();
</script>

</html>