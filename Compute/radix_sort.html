<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/webgpuunleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/webgpuunleashed/Compute/radix_sort.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/webgpuunleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/webgpuunleashed/Compute/radix_sort.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/webgpuunleashed/meta.png" />

    <link rel="stylesheet" href="/webgpuunleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/webgpuunleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/webgpuunleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/webgpuunleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/webgpuunleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/webgpuunleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/webgpuunleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/webgpuunleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/webgpuunleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/webgpuunleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/webgpuunleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/webgpuunleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/webgpuunleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/webgpuunleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/webgpuunleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/webgpuunleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/webgpuunleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/webgpuunleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/webgpuunleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/webgpuunleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/webgpuunleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/webgpuunleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/webgpuunleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/webgpuunleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/webgpuunleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/webgpuunleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/webgpuunleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/webgpuunleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/webgpuunleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/webgpuunleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/webgpuunleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/webgpuunleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/webgpuunleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/webgpuunleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/webgpuunleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/webgpuunleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >4.1 Radix Sort</h2><p>Prefix sum is a crucial foundation for numerous parallel algorithms. In this chapter, we explore its role in constructing another fundamental element: a sorting algorithm known as radix sort. This sorting technique will be instrumental in our next chapter, where we apply it to implement Gaussian splatting.</p><p>The goal of radix sort is to arrange key-value pairs based on their keys, where each key is an integer. This sorting process involves examining one digit of all keys at a time. For instance, if all keys are decimal numbers less than 100, each key has two digits. During sorting, we first consider the least significant digit and rearrange the entire list based on that digit alone. Next, we move on to the most significant digit and reorder the list again. It's important to note that each step of reordering must be a stable sort. This means that if two elements have the same key, the one that appeared earlier in the input will also appear earlier in the sorted output. By ensuring this stability, the order established during the first pass based on the least significant digit can be maintained while performing subsequent passes. Therefore, once we have sorted the list digit by digit, we can be confident that the final list will be ordered by the key.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="thumb_radix.png" original_src="radix.png" alt="Example of Radix Sort" sources='[]' /><div class="img-title">Example of Radix Sort</div></div></p><p>How is radix sort related to prefix sum? Let's illustrate this relationship using an even simpler case: binary keys. When our keys are binary, with only two possible values (zero and one) for each digit, sorting by a single digit is akin to performing a prefix sum on the occurrences of zeros and ones. Once we have computed the prefix sum, we can predict the new position in the sorted list for each element. For instance, if an element is zero and we know the prefix sum <code class="language-math math-inline">k</code> of all zero occurrences, the element's new location in the sorted list should be <code class="language-math math-inline">k+1</code>. Similarly, if an element is one and we know the prefix sum <code class="language-math math-inline">w</code> of all one occurrences, the element's new location should be <code class="language-math math-inline">w+1+z</code>, where <code class="language-math math-inline">z</code> is the count of all zeros.</p><p>This approach can be readily extended to digits of a different numeral system, such as decimal. However, there's a trade-off to consider when selecting the numeral system. Using a system with fewer possible values for a digit, like binary, results in keys with more digits. Consequently, more iterations are needed to complete the sorting process. Conversely, opting for a system with more values per digit shortens the key length but requires more prefix sums in each iteration and more storage to keep track of them. In our example, we will use the Quaternary numeral system.</p><p>What has been described so far is the basic concept. In practice, however, there are additional considerations, primarily due to the 256-workgroup size limit, which means we can only work on arrays of up to size 512. For longer lists, we need to divide the list into multiple 512-sized chunks. To address this, we divide our sorting algorithm into three phases.</p><p>In the first phase, we compute prefix sums within each chunk and save the results, which we refer to as local prefix sums. Additionally, we write the total count of all possible digit values into a global list.</p><p>The second phase involves computing another set of prefix sums on this global list.</p><p>The final phase is the shuffling phase. Here, based on the local prefix sums and the global digit value count, we determine the sorted position of each element in the resulting array and write the value to that location.</p><p>To completely sort a list, we must repeat the three-phase process described above for the entire length of the key's digits.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=20>@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read_write&gt; output :array&lt;vec4&lt;u32&gt;&gt;;
@binding(2) @group(0) var&lt;storage, read_write&gt; sums: array&lt;u32&gt;;
@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;
const bank_size:u32 = 32;
const n:u32 = 512;
var&lt;workgroup&gt; temp0: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp1: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp2: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp3: array&lt;u32,532&gt;;
fn bank_conflict_free_idx( idx:u32) -&gt; u32 {
  var chunk_id:u32 = idx / bank_size;
  return idx + chunk_id;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3&lt;u32&gt;,
  @builtin(local_invocation_id) LocalInvocationID: vec3&lt;u32&gt;,
  @builtin(workgroup_id) WorkgroupID: vec3&lt;u32&gt;) {
      var thid:u32 = LocalInvocationID.x;
      var globalThid:u32 = GlobalInvocationID.x;
      var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);
      if (thid &lt; (n&gt;&gt;1)){

          var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

          if (val == 0) {
              temp0[bank_conflict_free_idx(2*thid)] = 1;
          }
          else if (val == 1) {
              temp1[bank_conflict_free_idx(2*thid)] = 1;
          }
          else if (val == 2) {
              temp2[bank_conflict_free_idx(2*thid)] = 1;
          }
          else if (val == 3) {
              temp3[bank_conflict_free_idx(2*thid)] = 1;
          }

          val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

          if (val == 0) {
              temp0[bank_conflict_free_idx(2*thid+1)] = 1;
          }
          else if (val == 1) {
              temp1[bank_conflict_free_idx(2*thid+1)] = 1;
          }
          else if (val == 2) {
              temp2[bank_conflict_free_idx(2*thid+1)] = 1;
          }
          else if (val == 3) {
              temp3[bank_conflict_free_idx(2*thid+1)] = 1;
          }
      }
      workgroupBarrier();
      var offset:u32 = 1;

      for (var d:u32 = n&gt;&gt;1; d &gt; 0; d &gt;&gt;= 1)
      { 
          if (thid &lt; d)    
          {
              var ai:u32 = offset*(2*thid+1)-1;     
              var bi:u32 = offset*(2*thid+2)-1;  
              temp0[bank_conflict_free_idx(bi)] += temp0[bank_conflict_free_idx(ai)]; 
              temp1[bank_conflict_free_idx(bi)] += temp1[bank_conflict_free_idx(ai)]; 
              temp2[bank_conflict_free_idx(bi)] += temp2[bank_conflict_free_idx(ai)]; 
              temp3[bank_conflict_free_idx(bi)] += temp3[bank_conflict_free_idx(ai)]; 

          }    
          offset *= 2; 

          workgroupBarrier();   
      }

      if (thid == 0) 
      { 
          temp0[bank_conflict_free_idx(n - 1)] = 0; 
          temp1[bank_conflict_free_idx(n - 1)] = 0; 
          temp2[bank_conflict_free_idx(n - 1)] = 0; 
          temp3[bank_conflict_free_idx(n - 1)] = 0; 
      }
      workgroupBarrier();      

      for (var d:u32 = 1; d &lt; n; d *= 2) // traverse down tree &amp; build scan 
      {      
          offset &gt;&gt;= 1;      
          if (thid &lt; d)      
          { 
              var ai:u32 = offset*(2*thid+1)-1;     
              var bi:u32 = offset*(2*thid+2)-1; 
              var t:u32 = temp0[bank_conflict_free_idx(ai)]; 
              temp0[bank_conflict_free_idx(ai)] = temp0[bank_conflict_free_idx(bi)]; 
              temp0[bank_conflict_free_idx(bi)] += t;     
              
              
              t = temp1[bank_conflict_free_idx(ai)]; 
              temp1[bank_conflict_free_idx(ai)] = temp1[bank_conflict_free_idx(bi)]; 
              temp1[bank_conflict_free_idx(bi)] += t; 
              
              t = temp2[bank_conflict_free_idx(ai)]; 
              temp2[bank_conflict_free_idx(ai)] = temp2[bank_conflict_free_idx(bi)]; 
              temp2[bank_conflict_free_idx(bi)] += t;  
              
              t = temp3[bank_conflict_free_idx(ai)]; 
              temp3[bank_conflict_free_idx(ai)] = temp3[bank_conflict_free_idx(bi)]; 
              temp3[bank_conflict_free_idx(bi)] += t;     
          } 
          workgroupBarrier();      
      }
      if (thid == 0) {
          var count0:u32 = temp0[bank_conflict_free_idx(2*255)];
          var count1:u32 = temp1[bank_conflict_free_idx(2*255)];
          var count2:u32 = temp2[bank_conflict_free_idx(2*255)];
          var count3:u32 = temp3[bank_conflict_free_idx(2*255)];

          var last:u32 =  (input[2*((WorkgroupID.x+1) * 256-1)] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
          switch(last) {
              case 0: {count0 += 1;}
              case 1: {count1 += 1;}
              case 2: {count2 += 1;}
              case 3: {count3 += 1;}
              default {}
          }

          last =  (input[2*((WorkgroupID.x+1) * 256-1)+1] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
          switch(last) {
              case 0: {count0 += 1;}
              case 1: {count1 += 1;}
              case 2: {count2 += 1;}
              case 3: {count3 += 1;}
              default {}
          }

          sums[WorkgroupID.x * 4] = count0;
          sums[WorkgroupID.x * 4+1] = count1;
          sums[WorkgroupID.x * 4+2] = count2;
          sums[WorkgroupID.x * 4+3] = count3;
      }
      if (thid &lt; (n&gt;&gt;1)){
          output[2*globalThid].x = temp0[bank_conflict_free_idx(2*thid)]; 
          output[2*globalThid+1].x = temp0[bank_conflict_free_idx(2*thid+1)]; 

          output[2*globalThid].y = temp1[bank_conflict_free_idx(2*thid)]; 
          output[2*globalThid+1].y = temp1[bank_conflict_free_idx(2*thid+1)]; 

          output[2*globalThid].z = temp2[bank_conflict_free_idx(2*thid)]; 
          output[2*globalThid+1].z = temp2[bank_conflict_free_idx(2*thid+1)]; 

          output[2*globalThid].w = temp3[bank_conflict_free_idx(2*thid)]; 
          output[2*globalThid+1].w = temp3[bank_conflict_free_idx(2*thid+1)]; 
      }
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=19:170#4_01_radix_sorting">4_01_radix_sorting/index.html:20-171 Modified Prefix Sum</a></div></div><p>The code above is a modification of the prefix sum algorithm we discussed in the previous chapter. Here, I'll focus on explaining the modifications. Let's start with the input and output:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=20>@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read_write&gt; output :array&lt;vec4&lt;u32&gt;&gt;;
@binding(2) @group(0) var&lt;storage, read_write&gt; sums: array&lt;u32&gt;;
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=19:21#4_01_radix_sorting">4_01_radix_sorting/index.html:20-22 Input Buffers</a></div></div><p>The input array remains the same, but the output now stores vec4 vectors. Since we are using the quaternary numeral system, the vector stores the sums for digits 0, 1, 2, and 3. Additionally, we have a sums array to keep track of the total counts of all digits within each chunk.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=23>@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=22:22#4_01_radix_sorting">4_01_radix_sorting/index.html:23-23 The radixMaskId Defines the Current Focus Digit</a></div></div><p>Next, we define the radixMaskId, which indicates the current digit we should focus on. Given that our key is in the format uint32 and we are using the quaternary numeral system, we have 16 possible digits. Therefore, the value of radixMaskId ranges from 0 to 15. Using radixMaskId, we can calculate the mask with the following formula:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=41>var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=40:40#4_01_radix_sorting">4_01_radix_sorting/index.html:41-41 The Calculation From the radixMaskId the the Actual Mask for the Current Digit</a></div></div><p>Next, we define a set of temporary arrays for calculations:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=25>const n:u32 = 512;
var&lt;workgroup&gt; temp0: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp1: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp2: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp3: array&lt;u32,532&gt;;
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=24:28#4_01_radix_sorting">4_01_radix_sorting/index.html:25-29 Temp Arrays</a></div></div><p>The following step is to load the values into the temporary arrays. We extract the current digit of interest, and based on the digit's value, we set the corresponding location in the temporary array to 1, indicating one occurrence.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=39>var thid:u32 = LocalInvocationID.x;
var globalThid:u32 = GlobalInvocationID.x;
var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);
if (thid &lt; (n&gt;&gt;1)){

    var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

    if (val == 0) {
        temp0[bank_conflict_free_idx(2*thid)] = 1;
    }
    else if (val == 1) {
        temp1[bank_conflict_free_idx(2*thid)] = 1;
    }
    else if (val == 2) {
        temp2[bank_conflict_free_idx(2*thid)] = 1;
    }
    else if (val == 3) {
        temp3[bank_conflict_free_idx(2*thid)] = 1;
    }

    val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

    if (val == 0) {
        temp0[bank_conflict_free_idx(2*thid+1)] = 1;
    }
    else if (val == 1) {
        temp1[bank_conflict_free_idx(2*thid+1)] = 1;
    }
    else if (val == 2) {
        temp2[bank_conflict_free_idx(2*thid+1)] = 1;
    }
    else if (val == 3) {
        temp3[bank_conflict_free_idx(2*thid+1)] = 1;
    }
}
workgroupBarrier();
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=38:73#4_01_radix_sorting">4_01_radix_sorting/index.html:39-74 Temp Array Loading</a></div></div><p>The following logic is similar to the prefix sum program, with the key difference being that we perform it on the four temporary arrays. Once the prefix sums are calculated, we need to get the overall counts of the digits in this chunk. Since our prefix sum doesn't include the last value, we need to retrieve the last element of the prefix sum array, count the last input element, and save the result into the sums array. Note that we only ask the first thread of this workgroup to perform the saving operation since each workgroup only produces one set of these values.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=129>if (thid == 0) {
    var count0:u32 = temp0[bank_conflict_free_idx(2*255)];
    var count1:u32 = temp1[bank_conflict_free_idx(2*255)];
    var count2:u32 = temp2[bank_conflict_free_idx(2*255)];
    var count3:u32 = temp3[bank_conflict_free_idx(2*255)];

    var last:u32 =  (input[2*((WorkgroupID.x+1) * 256-1)] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    last =  (input[2*((WorkgroupID.x+1) * 256-1)+1] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    sums[WorkgroupID.x * 4] = count0;
    sums[WorkgroupID.x * 4+1] = count1;
    sums[WorkgroupID.x * 4+2] = count2;
    sums[WorkgroupID.x * 4+3] = count3;
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=128:156#4_01_radix_sorting">4_01_radix_sorting/index.html:129-157 Write Back Prefix Sum Result</a></div></div><p>The second pass involves another prefix sum, where we take the sums array generated in the previous pass and calculate its prefix sum. This pass follows a standard approach, so I will skip the detailed explanation. For simplicity, we assume that the number of chunks is less than 512, allowing us to perform the second pass with a single workgroup. This essentially limits the maximum array size we can process to 512x512.</p><p>The third pass is the shuffling pass. During this pass, we calculate each element's location in the sorted array and assign the corresponding digit value to the result array.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=260>@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read&gt; inputId :array&lt;u32&gt;;
@binding(2) @group(0) var&lt;storage, read&gt; temp :array&lt;vec4&lt;u32&gt;&gt;;
@binding(3) @group(0) var&lt;storage, read&gt; sums: array&lt;u32&gt;;
@binding(4) @group(0) var&lt;uniform&gt; sumSize: u32;
@binding(5) @group(0) var&lt;storage, read_write&gt; output :array&lt;u32&gt;;
@binding(6) @group(0) var&lt;storage, read_write&gt; outputId :array&lt;u32&gt;;
const n:u32 = 512;

@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3&lt;u32&gt;,
  @builtin(local_invocation_id) LocalInvocationID: vec3&lt;u32&gt;,
  @builtin(workgroup_id) WorkgroupID: vec3&lt;u32&gt;) {
    var thid:u32 = LocalInvocationID.x;
    var globalThid:u32 = GlobalInvocationID.x;
    var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);
    
    var count0beforeCurrentWorkgroup:u32 = 0;
    var count1beforeCurrentWorkgroup:u32 = 0;
    var count2beforeCurrentWorkgroup:u32 = 0;
    var count3beforeCurrentWorkgroup:u32 = 0;

    if (WorkgroupID.x &gt; 0) {
     count0beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4];
     count1beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4+1];
     count2beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4+2];
     count3beforeCurrentWorkgroup =  sums[(WorkgroupID.x-1) * 4+3];
    }

    var count0overall:u32 = sums[(sumSize-1)*4];
    var count1overall:u32 = sums[(sumSize-1)*4+1];
    var count2overall:u32 = sums[(sumSize-1)*4+2];
    var count3overall:u32 = sums[(sumSize-1)*4+3];

    if (thid &lt; (n&gt;&gt;1)){
        var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

        var id:u32 = 0;

        if (val == 0) {
            id += temp[2*globalThid].x + count0beforeCurrentWorkgroup;
        }
        else if (val == 1) {
            id +=count0overall;
            id += temp[2*globalThid].y + count1beforeCurrentWorkgroup;
        }
        else if (val == 2) {
            id += count0overall;
            id += count1overall;
            id += temp[2*globalThid].z +  count2beforeCurrentWorkgroup;
        }
        else if (val == 3) {
            id +=count0overall;
            id +=count1overall;
            id +=count2overall;
            id += temp[2*globalThid].w +count3beforeCurrentWorkgroup;
        }

        output[id] = input[2*globalThid]; 
        outputId[id] = inputId[2*globalThid];
        //output[2*globalThid] = id;

        id = 0;

        val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

        if (val == 0) {
            id += temp[2*globalThid+1].x +  count0beforeCurrentWorkgroup;
        }
        else if (val == 1) {
            id +=count0overall;
            id += temp[2*globalThid+1].y + count1beforeCurrentWorkgroup;
        }
        else if (val == 2) {
            id += count0overall;
            id += count1overall;
            id += temp[2*globalThid+1].z +  count2beforeCurrentWorkgroup;
        }
        else if (val == 3) {
            id +=count0overall;
            id +=count1overall;
            id +=count2overall;
            id += temp[2*globalThid+1].w+ count3beforeCurrentWorkgroup ;
        }

        output[id] = input[2*globalThid+1];
        outputId[id] = inputId[2*globalThid+1];

        //output[2*globalThid+1] = id;
    }
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=259:351#4_01_radix_sorting">4_01_radix_sorting/index.html:260-352 The Shuffling Phase</a></div></div><p>Now let's look at the JavaScript side and see how we set up the input data and trigger the compute shader.</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=522>let testArray = [];
let testIdArray = [];
{
    //load data
    const objResponse = await fetch('../data/dummy.json');
    testArray = await objResponse.json();
}

const actualArraySize = testArray.length; // 81946;//512*2+10;
const paddedArraySize = Math.ceil(actualArraySize / 512) * 512;
const chunkCount = Math.ceil(paddedArraySize / 512);

let sumSize = roundUpToNearestPowOf2(chunkCount);

console.log("pos", Number.POSITIVE_INFINITY)
for (let i = 0; i &lt; paddedArraySize; ++i) {
    if (i &lt; actualArraySize) {
        // testArray.push(Math.floor(random() * 0xFFFFFFFE));
    } else {
        testArray.push(0xFFFFFFFF);
    }
    testIdArray.push(i);
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=521:543#4_01_radix_sorting">4_01_radix_sorting/index.html:522-544 Prepare Inputs</a></div></div><p>The testArray is our input array. Instead of generating a random array, the input data is read from a file created during debugging the previous chapter's sample. You can think of it as a random array. We have two array sizes: actualArraySize, which is the true size of the input array, and paddedArraySize, which is the array size rounded up to the nearest multiple of 512. This is because a single workgroup can sort an array of 512 elements.</p><p>We also have a chunkCount variable representing the number of workgroups or chunks. As previously mentioned, the digit counts in each chunk will be accumulated in the second prefix sum pass. The sumSize is rounded to the nearest power of two, necessary for calculating the parallel prefix sum using a binary tree structure.</p><p>For the padded values, we assign them a large number 0xFFFFFFFF to ensure they appear at the end of the sorted array. The next step involves setting up a series of GPU buffers to hold the input and output arrays, which I will skip as they are straightforward.</p><p>We also need to set up the radix mask:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=561>let radixIdUniformBuffers = [];

for (let i = 0; i &lt; 16; ++i) {
    let radixIdUniformBuffer = createGPUBuffer(device, new Uint32Array([i]), GPUBufferUsage.UNIFORM);

    radixIdUniformBuffers.push(radixIdUniformBuffer);
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=560:566#4_01_radix_sorting">4_01_radix_sorting/index.html:561-567 Radix Mask Setup</a></div></div><p>Since we are using the quaternary numeral system, each time we look at two binary digits. Our mask is 0b11, which is shifted left according to the position of the radix. Instead of directly encoding the masks, we encode the positions of the masks. For an unsigned 32-bit integer, there are 16 digit positions. Therefore, we set the radixId to range from 0 to 15. We encode these positions into separate GPU buffers so that during calculation, we can specify the radixId easily by loading the corresponding uniform buffer.</p><p>Finally, let's look at how the three passes are triggered:</p><div class="code-fragments"><pre><code class="language-javascript code-block" startNumber=794>const commandEncoder = device.createCommandEncoder();
if (hasTimestampQuery) {
    commandEncoder.writeTimestamp(querySet, 0);// Initial timestamp
}

for (let i = 0; i &lt; 16; ++i) {
    const passEncoder = commandEncoder.beginComputePass(
        computePassDescriptor
    );

    passEncoder.setPipeline(pass1ComputePipeline);
    if (i % 2 == 0) {
        passEncoder.setBindGroup(0, pass1UniformBindGroupInputOutput0);
    }
    else {
        passEncoder.setBindGroup(0, pass1UniformBindGroupInputOutput1);
    }
    passEncoder.setBindGroup(1, pass13UniformBindGroupRadixIds[i]);
    passEncoder.dispatchWorkgroups(chunkCount);
    passEncoder.end();


    const pass2Encoder = commandEncoder.beginComputePass(computePassDescriptor);
    pass2Encoder.setPipeline(pass2ComputePipeline);
    pass2Encoder.setBindGroup(0, pass2UniformBindGroup);
    pass2Encoder.dispatchWorkgroups(1);
    pass2Encoder.end();


    const pass3Encoder = commandEncoder.beginComputePass(computePassDescriptor);
    pass3Encoder.setPipeline(pass3ComputePipeline);
    if (i % 2 == 0) {
        pass3Encoder.setBindGroup(0, pass3UniformBindGroup0);
    } else {
        pass3Encoder.setBindGroup(0, pass3UniformBindGroup1);
    }
    pass3Encoder.setBindGroup(1, pass13UniformBindGroupRadixIds[i]);
    pass3Encoder.dispatchWorkgroups(chunkCount);
    pass3Encoder.end();
}
</pre></code><div class="code-fragments-caption"><a target="_blank" href="https://shi-yan.github.io/webgpuunleashed/code/code.html?highlight=793:832#4_01_radix_sorting">4_01_radix_sorting/index.html:794-833 Command Submission</a></div></div><p>We loop 16 times because we have 16 radix positions. Each iteration accomplishes three passes. For the first and third passes, we alternate the roles of the input and output arrays to improve efficiency and avoid unnecessary data copying. Finally, we read back the sorted array, but I will skip the details.</p>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/webgpuunleashed/Compute/prefix_sum.html">Prefix Sum</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/webgpuunleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/webgpuunleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
    <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-G278P1YSJ6"></script>
<script>
window.dataLayer = window.dataLayer || [];
function gtag() { dataLayer.push(arguments); }
gtag('js', new Date());
gtag('config', 'G-G278P1YSJ6');
</script>
</body>

</html>