<!DOCTYPE html>
<html>

<head>
    <meta charset="UTF-8" />
    <meta http-equiv="X-UA-Compatible" content="IE=edge" />
    <meta name="viewport" content="width=device-width,initial-scale=1.0" />
    <link rel="shortcut icon" type="image/x-icon" href="/WebGPUUnleashed/favicon.ico">
    <!-- Primary Meta Tags -->
    <title>WebGPU Unleashed: A Practical Tutorial</title>
    <meta name="title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta name="description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />

    <!-- Open Graph / Facebook -->
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://shi-yan.github.io/WebGPUUnleashed/Compute/radix_sort.html" />
    <meta property="og:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="og:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="og:image" content="/WebGPUUnleashed/meta.png" />

    <!-- Twitter -->
    <meta property="twitter:card" content="summary_large_image" />
    <meta property="twitter:url" content="https://shi-yan.github.io/WebGPUUnleashed/Compute/radix_sort.html" />
    <meta property="twitter:title" content="WebGPU Unleashed: A Practical Tutorial" />
    <meta property="twitter:description" content="WebGPU Unleashed, your ticket to the dynamic world of graphics programming. Dive in and discover the magic of creating stunning visuals from scratch, mastering the art of real-time graphics, and unlocking the power of WebGPU - all in one captivating tutorial." />
    <meta property="twitter:image" content="/WebGPUUnleashed/meta.png" />

    <link rel="stylesheet" href="/WebGPUUnleashed/style.css" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" />
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script
        src="https://cdnjs.cloudflare.com/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/languages/javascript.min.js"></script>


    <link rel="stylesheet"
        href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/base16/default-dark.min.css"
        integrity="sha512-EF2rc4QyBiRAGUMVm+EjFPBbdVGaN/pwZhtuKyrC/dM+hcwTxI5BsEDUkrMRI77z4VlDAt/qVopePXB5+ZZ8Gw=="
        crossorigin="anonymous" referrerpolicy="no-referrer" />
    <script src="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.js
        "></script>
    <link href="
        https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.9/katex.min.css
        " rel="stylesheet" />
</head>

<body>
    <div id="menuToggle">
        <input id="menuButton" type="checkbox" />
        <span></span>
        <span></span>
        <span></span>
        <div id="menu-container">
            <ul id="menu">
                <!--<li><a href="#">Home</a></li>
                <li><a href="#">About</a></li>
                <li><a id="test" href="#" onclick="fold(event)">Info</a>
                    <ul class="sub-menu">
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                        <li><a href="#">test menu;</a></li>
                    </ul>
                </li>
                <li><a href="#">Contact</a></li>
                <li><a href="https://erikterwan.com/" target="_blank">Show me more</a></li>-->
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed">Home</a></li>
                <li><a href="#" onclick="fold(event)">Intro</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_driver.html">The GPU Driver</a></li>
                        <li><a href="/WebGPUUnleashed/Introduction/the_gpu_pipeline.html">The GPU Pipeline</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Basics</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Basics/creating_an_empty_canvas.html">Creating an Empty Canvas</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle.html">Drawing a Triangle</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_triangle_with_defined_vertices.html">Drawing a Triangle with Defined Vertices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/applying_hardcoded_vertex_colors.html">Applying Hardcoded Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/using_different_vertex_colors.html">Using Different Vertex Colors</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/drawing_a_colored_triangle_with_a_single_buffer.html">Drawing a Colored Triangle with a Single Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_uniforms.html">Understanding Uniforms</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/working_with_textures.html">Working with Textures</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/utilizing_transformation_matrices.html">Utilizing Transformation Matrices</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/implementing_cameras.html">Implementing Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/triangle_strips.html">Triangle Strips</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/front_and_back_face_culling.html">Front and Back Face Culling</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/depth_testing.html">Depth Testing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/index_buffers.html">Index Buffers</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/loading_3d_models.html">Loading 3D Models</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/understanding_normals.html">Understanding Normals</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/lighting.html">Lighting</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/multi_sample_anti_aliasing.html">Multi-Sample Anti-Aliasing</a></li>
                        <li><a href="/WebGPUUnleashed/Basics/mipmapping_and_anisotropic_filtering.html">Mipmapping and Anisotropic Filtering</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">2D Techniques</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/2D_Techniques/rendering_to_textures.html">Rendering to Textures</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/orthogonal_cameras.html">Orthogonal Cameras</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_gaussian_blur.html">Implementing Gaussian Blur</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/video_rendering.html">Video Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/text_rendering.html">Text Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/billboarding.html">Billboarding</a></li>
                        <li><a href="/WebGPUUnleashed/2D_Techniques/implementing_fake_3d.html">Implementing Fake 3D</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Control</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Control/canvas_resizing.html">Canvas Resizing</a></li>
                        <li><a href="/WebGPUUnleashed/Control/arcball_camera_control.html">Arcball Camera Control</a></li>
                        <li><a href="/WebGPUUnleashed/Control/object_picking.html">Object Picking</a></li>
                        <li><a href="/WebGPUUnleashed/Control/saving_images_and_videos.html">Saving Images and Videos</a></li>
                        <li><a href="/WebGPUUnleashed/Control/using_web_workers.html">Using Web Workers</a></li>
                        <li><a href="/WebGPUUnleashed/Control/error_handling_and_limits.html">Error Handling and Limits</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Compute</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/radix_sort.html">Radix Sort</a></li>
                        <li><a href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a></li>
                    </ul>
                </li>
                <li><a href="#" onclick="fold(event)">Advanced</a>
                    <ul class="sub-menu">
                        <li><a href="/WebGPUUnleashed/Advanced/stencil_buffer.html">Stencil Buffer</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/shadow_mapping.html">Shadow Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/toon_shading.html">Toon Shading</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/equirectangular_rendering.html">Equirectangular Rendering</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/mega_texture.html">Mega Texture</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/transparency_with_depth_peeling.html">Transparency with Depth Peeling</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/skeleton_animation.html">Skeleton Animation</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/normal_mapping_and_bump_mapping.html">Normal Mapping and Bump Mapping</a></li>
                        <li><a href="/WebGPUUnleashed/Advanced/gaussian_splatting.html">Gaussian Splatting</a></li>
                    </ul>
                </li>
                <li><a href="https://shi-yan.github.io/WebGPUUnleashed/code/code.html" target="_blank">Playground</a></li>
                <li><a href="https://github.com/shi-yan/WebGPUUnleashed" target="_blank">GitHub Repo</a></li>
            </ul>
        </div>
    </div>

    <div id="article-container">
        <article>
            <h2 >4.1 Radix Sort</h2><p>Prefix sum is a crucial foundation for numerous parallel algorithms. In this chapter, we explore its role in constructing another fundamental element: a sorting algorithm known as radix sort. This sorting technique will be instrumental in our next chapter, where we apply it to implement Gaussian splatting.</p><p>The goal of radix sort is to arrange key-value pairs based on their keys, where each key is an integer. This sorting process involves examining one digit of all keys at a time. For instance, if all keys are decimal numbers less than 100, each key has two digits. During sorting, we first consider the least significant digit and rearrange the entire list based on that digit alone. Next, we move on to the most significant digit and reorder the list again. It's important to note that each step of reordering must be a stable sort. This means that if two elements have the same key, the one that appeared earlier in the input will also appear earlier in the sorted output. By ensuring this stability, the order established during the first pass based on the least significant digit can be maintained while performing subsequent passes. Therefore, once we have sorted the list digit by digit, we can be confident that the final list will be ordered by the key.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="placeholder.jpg" alt="An Image Shows a Concrete Sorting Example" sources='[]' /><div class="img-title">An Image Shows a Concrete Sorting Example</div></div></p><p>How is radix sort related to prefix sum? Let's illustrate this relationship using an even simpler case: binary keys. When our keys are binary, with only two possible values (zero and one) for each digit, sorting by a single digit is akin to performing a prefix sum on the occurrences of zeros and ones. Once we have computed the prefix sum, we can predict the new position in the sorted list for each element. For instance, if an element is zero and we know the prefix sum <code class="language-math math-inline">k</code> of all zero occurrences, the element's new location in the sorted list should be <code class="language-math math-inline">k+1</code>. Similarly, if an element is one and we know the prefix sum <code class="language-math math-inline">w</code> of all one occurrences, the element's new location should be <code class="language-math math-inline">w+1+z</code>, where <code class="language-math math-inline">z</code> is the count of all zeros.</p><p><div class="img-container"><img class="img" onclick="openImage(this)" src="placeholder.jpg" alt="An Image Shows a Concrete Sorting Example" sources='[]' /><div class="img-title">An Image Shows a Concrete Sorting Example</div></div></p><p>This approach can be readily extended to digits of a different numeral system, such as decimal. However, there's a trade-off to consider when selecting the numeral system. Using a system with fewer possible values for a digit, like binary, results in keys with more digits. Consequently, more iterations are needed to complete the sorting process. Conversely, opting for a system with more values per digit shortens the key length but requires more prefix sums in each iteration and more storage to keep track of them. In our example, we will use the Quaternary numeral system.</p><p>What has been described so far is the basic concept. In practice, however, there are additional considerations, primarily due to the 256-workgroup size limit, which means we can only work on arrays of up to size 512. For longer lists, we need to divide the list into multiple 512-sized chunks. To address this, we divide our sorting algorithm into three phases.</p><p>In the first phase, we compute prefix sums within each chunk and save the results, which we refer to as local prefix sums. Additionally, we write the total count of all possible digit values into a global list.</p><p>The second phase involves computing another set of prefix sums on this global list.</p><p>The final phase is the shuffling phase. Here, based on the local prefix sums and the global digit value count, we determine the sorted position of each element in the resulting array and write the value to that location.</p><p>To completely sort a list, we must repeat the three-phase process described above for the entire length of the key's digits.</p><pre><code class="language-javascript code-block">@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read_write&gt; output :array&lt;vec4&lt;u32&gt;&gt;;
@binding(2) @group(0) var&lt;storage, read_write&gt; sums: array&lt;u32&gt;;

@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;

const bank_size:u32 = 32;
const n:u32 = 512;
var&lt;workgroup&gt; temp0: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp1: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp2: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp3: array&lt;u32,532&gt;;

fn bank_conflict_free_idx( idx:u32) -&gt; u32 {
    var chunk_id:u32 = idx / bank_size;
    return idx + chunk_id;
}

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3&lt;u32&gt;,
        @builtin(local_invocation_id) LocalInvocationID: vec3&lt;u32&gt;,
        @builtin(workgroup_id) WorkgroupID: vec3&lt;u32&gt;) {
    var thid:u32 = LocalInvocationID.x;
    var globalThid:u32 = GlobalInvocationID.x;
    var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);

    if (thid &lt; (n&gt;&gt;1)){
        var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);
        if (val == 0) {
            temp0[bank_conflict_free_idx(2*thid)] = 1;
        } else if (val == 1) {
            temp1[bank_conflict_free_idx(2*thid)] = 1;
        } else if (val == 2) {
            temp2[bank_conflict_free_idx(2*thid)] = 1;
        } else if (val == 3) {
            temp3[bank_conflict_free_idx(2*thid)] = 1;
        }

        val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

        if (val == 0) {
            temp0[bank_conflict_free_idx(2*thid+1)] = 1;
        } else if (val == 1) {
            temp1[bank_conflict_free_idx(2*thid+1)] = 1;
        } else if (val == 2) {
            temp2[bank_conflict_free_idx(2*thid+1)] = 1;
        } else if (val == 3) {
            temp3[bank_conflict_free_idx(2*thid+1)] = 1;
        }
    }
    workgroupBarrier();
    var offset:u32 = 1;

    for (var d:u32 = n&gt;&gt;1; d &gt; 0; d &gt;&gt;= 1) { 
        if (thid &lt; d) {
            var ai:u32 = offset*(2*thid+1)-1;     
            var bi:u32 = offset*(2*thid+2)-1;  
            temp0[bank_conflict_free_idx(bi)] += temp0[bank_conflict_free_idx(ai)]; 
            temp1[bank_conflict_free_idx(bi)] += temp1[bank_conflict_free_idx(ai)]; 
            temp2[bank_conflict_free_idx(bi)] += temp2[bank_conflict_free_idx(ai)]; 
            temp3[bank_conflict_free_idx(bi)] += temp3[bank_conflict_free_idx(ai)]; 
        }
        offset *= 2;
        workgroupBarrier();   
    }

    if (thid == 0) { 
        temp0[bank_conflict_free_idx(n - 1)] = 0; 
        temp1[bank_conflict_free_idx(n - 1)] = 0; 
        temp2[bank_conflict_free_idx(n - 1)] = 0; 
        temp3[bank_conflict_free_idx(n - 1)] = 0; 
    }
    workgroupBarrier();      

    for (var d:u32 = 1; d &lt; n; d *= 2) // traverse down tree &amp; build scan 
    {      
        offset &gt;&gt;= 1;      
        if (thid &lt; d)      
        { 
            var ai:u32 = offset*(2*thid+1)-1;     
            var bi:u32 = offset*(2*thid+2)-1; 
            var t:u32 = temp0[bank_conflict_free_idx(ai)]; 
            temp0[bank_conflict_free_idx(ai)] = temp0[bank_conflict_free_idx(bi)]; 
            temp0[bank_conflict_free_idx(bi)] += t;     
                            
            t = temp1[bank_conflict_free_idx(ai)]; 
            temp1[bank_conflict_free_idx(ai)] = temp1[bank_conflict_free_idx(bi)]; 
            temp1[bank_conflict_free_idx(bi)] += t; 
                    
            t = temp2[bank_conflict_free_idx(ai)]; 
            temp2[bank_conflict_free_idx(ai)] = temp2[bank_conflict_free_idx(bi)]; 
            temp2[bank_conflict_free_idx(bi)] += t;  
                    
            t = temp3[bank_conflict_free_idx(ai)]; 
            temp3[bank_conflict_free_idx(ai)] = temp3[bank_conflict_free_idx(bi)]; 
            temp3[bank_conflict_free_idx(bi)] += t;     
        } 
        workgroupBarrier();      
    }

    var count0:u32 = temp0[bank_conflict_free_idx(2*255)];
    var count1:u32 = temp1[bank_conflict_free_idx(2*255)];
    var count2:u32 = temp2[bank_conflict_free_idx(2*255)];
    var count3:u32 = temp3[bank_conflict_free_idx(2*255)];

    var last:u32 =  (input[2*((WorkgroupID.x+1) * 256-1)] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    last = (input[2*((WorkgroupID.x+1) * 256-1)+1] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    if (thid == 0) {
        sums[WorkgroupID.x * 4] = count0;
        sums[WorkgroupID.x * 4+1] = count1;
        sums[WorkgroupID.x * 4+2] = count2;
        sums[WorkgroupID.x * 4+3] = count3;
    }

    if (thid &lt; (n&gt;&gt;1)) {
        output[2*globalThid].x = temp0[bank_conflict_free_idx(2*thid)]; 
        output[2*globalThid+1].x = temp0[bank_conflict_free_idx(2*thid+1)]; 

        output[2*globalThid].y = temp1[bank_conflict_free_idx(2*thid)]; 
        output[2*globalThid+1].y = temp1[bank_conflict_free_idx(2*thid+1)]; 

        output[2*globalThid].z = temp2[bank_conflict_free_idx(2*thid)]; 
        output[2*globalThid+1].z = temp2[bank_conflict_free_idx(2*thid+1)]; 

        output[2*globalThid].w = temp3[bank_conflict_free_idx(2*thid)]; 
        output[2*globalThid+1].w = temp3[bank_conflict_free_idx(2*thid+1)]; 
    }
}</code></pre><p>the above code is a modification of the prefix sum we have seen in the previous chapter. here I'll focus on explaining the modified part. First, the input and output:</p><pre><code class="language-javascript code-block">@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read_write&gt; output :array&lt;vec4&lt;u32&gt;&gt;;
@binding(2) @group(0) var&lt;storage, read_write&gt; sums: array&lt;u32&gt;;</code></pre><p>The input array is the same, the output now saves vec4 vectors. Because we are using the Quaternary numeral system, we utilize the vector to save the sums for 0s,1s,2s,3s. And finally, we have a sums array to keep the total counts of all digits within each chunk.</p><pre><code class="language-javascript code-block">@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;</code></pre><p>We then have a maskId or the digitId. This defines the current digit we should focus. because our key is of the format uint32, and for the Quaternary numeral system, we have 16 digits. hence the value of radixMaskId is in the range [0,16]. given a maskId, we can calculate the mask using this formula:</p><pre><code class="language-javascript code-block">var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);</code></pre><p>Then we have a set of temporary arrays for calculation:</p><pre><code class="language-javascript code-block">const bank_size:u32 = 32;
const n:u32 = 512;
var&lt;workgroup&gt; temp0: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp1: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp2: array&lt;u32,532&gt;;
var&lt;workgroup&gt; temp3: array&lt;u32,532&gt;;</code></pre><p>The next step is loading the values into the temp arrays. We extract the current digit under interest, then based on the digit's value we set 1 to the corresponding temp array location, meaning one occurrence.</p><pre><code class="language-javascript code-block">var thid:u32 = LocalInvocationID.x;
var globalThid:u32 = GlobalInvocationID.x;
var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);

if (thid &lt; (n&gt;&gt;1)){
    var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);
    if (val == 0) {
        temp0[bank_conflict_free_idx(2*thid)] = 1;
    } else if (val == 1) {
        temp1[bank_conflict_free_idx(2*thid)] = 1;
    } else if (val == 2) {
        temp2[bank_conflict_free_idx(2*thid)] = 1;
    } else if (val == 3) {
        temp3[bank_conflict_free_idx(2*thid)] = 1;
    }

    val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

    if (val == 0) {
        temp0[bank_conflict_free_idx(2*thid+1)] = 1;
    } else if (val == 1) {
        temp1[bank_conflict_free_idx(2*thid+1)] = 1;
    } else if (val == 2) {
        temp2[bank_conflict_free_idx(2*thid+1)] = 1;
    } else if (val == 3) {
        temp3[bank_conflict_free_idx(2*thid+1)] = 1;
    }
}
workgroupBarrier();</code></pre><p>the following logic is the same as the prefix sum program. the difference is that we perform it on the four temporary arrays. once the prefix sums are calculated, we now need to get the overall counts of the digits in this chunk. since our prefix sum doesn't include the last value, what we need to do is getting the last element of the prefix sum array, then also count the last input element and save the result into the sums array. notice that we only ask the first thread of this workgroup to do the saving work, since each workgroup only produces one set of these values.</p><pre><code class="language-javascript code-block">if (thid == 0) {
    var count0:u32 = temp0[bank_conflict_free_idx(2*255)];
    var count1:u32 = temp1[bank_conflict_free_idx(2*255)];
    var count2:u32 = temp2[bank_conflict_free_idx(2*255)];
    var count3:u32 = temp3[bank_conflict_free_idx(2*255)];

    var last:u32 =  (input[2*((WorkgroupID.x+1) * 256-1)] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    last =  (input[2*((WorkgroupID.x+1) * 256-1)+1] &amp; mask)  &gt;&gt; (radixMaskId &lt;&lt; 1); 
    switch(last) {
        case 0: {count0 += 1;}
        case 1: {count1 += 1;}
        case 2: {count2 += 1;}
        case 3: {count3 += 1;}
        default {}
    }

    sums[WorkgroupID.x * 4] = count0;
    sums[WorkgroupID.x * 4+1] = count1;
    sums[WorkgroupID.x * 4+2] = count2;
    sums[WorkgroupID.x * 4+3] = count3;
}</code></pre><p>The second pass is another prefix sum, we take the sums array generated in the previous pass and calculate the prefix sum of it. The second pass is very standard, I will skip the detailed explanation. note that for simplicity reason, we assume that the number of chunks is less than 512, so that we can perform the second pass with one workgroup. this will essentially limit the maximum array size we can process to 512x512.</p><p>the third pass is the shuffling pass. during this pass, we calculate each element's location in the sorted array and assign the corresponding digit value to the result array.</p><pre><code class="language-javascript code-block">@binding(0) @group(0) var&lt;storage, read&gt; input :array&lt;u32&gt;;
@binding(1) @group(0) var&lt;storage, read&gt; inputId :array&lt;u32&gt;;
@binding(2) @group(0) var&lt;storage, read&gt; temp :array&lt;vec4&lt;u32&gt;&gt;;
@binding(3) @group(0) var&lt;storage, read&gt; sums: array&lt;u32&gt;;
@binding(4) @group(0) var&lt;uniform&gt; sumSize: u32;
@binding(5) @group(0) var&lt;storage, read_write&gt; output :array&lt;u32&gt;;
@binding(6) @group(0) var&lt;storage, read_write&gt; outputId :array&lt;u32&gt;;
const n:u32 = 512;

@binding(0) @group(1) var&lt;uniform&gt; radixMaskId:u32;

@compute @workgroup_size(256)
fn main(@builtin(global_invocation_id) GlobalInvocationID : vec3&lt;u32&gt;,
        @builtin(local_invocation_id) LocalInvocationID: vec3&lt;u32&gt;,
        @builtin(workgroup_id) WorkgroupID: vec3&lt;u32&gt;) {
    var thid:u32 = LocalInvocationID.x;
    var globalThid:u32 = GlobalInvocationID.x;
    var mask:u32 = u32(3) &lt;&lt; (radixMaskId &lt;&lt; 1);
        
    var count0beforeCurrentWorkgroup:u32 = 0;
    var count1beforeCurrentWorkgroup:u32 = 0;
    var count2beforeCurrentWorkgroup:u32 = 0;
    var count3beforeCurrentWorkgroup:u32 = 0;

    if (WorkgroupID.x &gt; 0) {
         count0beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4];
         count1beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4+1];
         count2beforeCurrentWorkgroup = sums[(WorkgroupID.x-1) * 4+2];
         count3beforeCurrentWorkgroup =  sums[(WorkgroupID.x-1) * 4+3];
    }

    var count0overall:u32 = sums[(sumSize-1)*4];
    var count1overall:u32 = sums[(sumSize-1)*4+1];
    var count2overall:u32 = sums[(sumSize-1)*4+2];
    var count3overall:u32 = sums[(sumSize-1)*4+3];

    if (thid &lt; (n&gt;&gt;1)) {
        var val:u32 = (input[2*globalThid] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);
        var id:u32 = 0;

        if (val == 0) {
            id += temp[2*globalThid].x + count0beforeCurrentWorkgroup;
        } else if (val == 1) {
            id +=count0overall;
            id += temp[2*globalThid].y + count1beforeCurrentWorkgroup;
        } else if (val == 2) {
            id += count0overall;
            id += count1overall;
            id += temp[2*globalThid].z +  count2beforeCurrentWorkgroup;
        } else if (val == 3) {
            id +=count0overall;
            id +=count1overall;
            id +=count2overall;
            id += temp[2*globalThid].w +count3beforeCurrentWorkgroup;
        }

        output[id] = input[2*globalThid]; 
        outputId[id] = inputId[2*globalThid];

        id = 0;

        val = (input[2*globalThid+1] &amp; mask) &gt;&gt; (radixMaskId &lt;&lt; 1);

        if (val == 0) {
            id += temp[2*globalThid+1].x +  count0beforeCurrentWorkgroup;
        } else if (val == 1) {
            id +=count0overall;
            id += temp[2*globalThid+1].y + count1beforeCurrentWorkgroup;
        } else if (val == 2) {
            id += count0overall;
            id += count1overall;
            id += temp[2*globalThid+1].z +  count2beforeCurrentWorkgroup;
        } else if (val == 3) {
            id +=count0overall;
            id +=count1overall;
            id +=count2overall;
            id += temp[2*globalThid+1].w+ count3beforeCurrentWorkgroup ;
        }

        output[id] = input[2*globalThid+1];
        outputId[id] = inputId[2*globalThid+1];
    }
}</code></pre><p>now let's look at the javascript side and see how we setup the input data and trigger the compute shader.</p><pre><code class="language-javascript code-block">        let testArray = [];
        let testIdArray = [];
        {
            //load data

            const objResponse = await fetch('../data/dummy.json');
            testArray = await objResponse.json();

        }

        const actualArraySize = testArray.length; // 81946;//512*2+10;
        const paddedArraySize = Math.ceil(actualArraySize / 512) * 512;
        const chunkCount = Math.ceil(paddedArraySize / 512);

        let sumSize = roundUpToNearestPowOf2(chunkCount);

        for (let i = 0; i &lt; paddedArraySize; ++i) {
            if (i &lt; actualArraySize) {
                // testArray.push(Math.floor(random() * 0xFFFFFFFE));
            } else {
                testArray.push(0xFFFFFFFF);
            }
            testIdArray.push(i);
        }</code></pre><p>The <code>testArray</code> is our input array. I'm not generating a random array, instead, the input data is read from a file. This file is created while debugging the last chapter sample. You can think of it as a random array. We have two array sizes, the <code>actualArraySize</code> is the true size of the input array. <code>paddedArraySize</code> is the array size rounded up to the smallest multiple of 512. This is because a single workgroup can sort an array of 512 elements.</p><p>we also have a <code>chunkCount</code> variable for the number of workgroups or chunks. as previously mentioned, the digit counts in each chunk will be accumulated in the second prefix sum pass. We have <code>sumSize</code> rounded to the nearest power of two. we need this rounding because when calculating the parallel prefix sum, we do it in a binary tree.</p><p>for the padded values, we assign them to a large number <code>0xFFFFFFFF</code>, because we want them to be at the end of the sorted array. The next step is setting up a series of gpu buffers to hold the input and output arrays. I will skip those, as they are nothing special.</p><p>We also need to set up the radix mask:</p><pre><code class="language-javascript code-block">        let radixIdUniformBuffers = [];

        for (let i = 0; i &lt; 16; ++i) {
            let radixIdUniformBuffer = createGPUBuffer(device, new Uint32Array([i]), GPUBufferUsage.UNIFORM);

            radixIdUniformBuffers.push(radixIdUniformBuffer);
        }</code></pre><p>because we are using the  Quaternary numeral system, each time, we look at two binary digits. Hence our mask is a 0b11 and shifted to the left according to the position of the radix. Instead of directly encode the masks, we encode the positions of the masks. for a unsigned 32 bit integer, there are 16 digit positions. We hence let the <code>radixId</code> be from 0 to 15. We encode them into separate gpu buffers, so that during calculation, we can specify the <code>radixId</code> easily by loading the corresponding uniform buffer.</p><p>finally, let's look at how the three passes are triggered:</p><pre><code class="language-javascript code-block">        const commandEncoder = device.createCommandEncoder();

        for (let i = 0; i &lt; 16; ++i) {
            const passEncoder = commandEncoder.beginComputePass(
                computePassDescriptor
            );

            passEncoder.setPipeline(pass1ComputePipeline);
            if (i % 2 == 0) {
                passEncoder.setBindGroup(0, pass1UniformBindGroupInputOutput0);
            }
            else {
                passEncoder.setBindGroup(0, pass1UniformBindGroupInputOutput1);
            }
            passEncoder.setBindGroup(1, pass13UniformBindGroupRadixIds[i]);
            passEncoder.dispatchWorkgroups(chunkCount);
            passEncoder.end();


            const pass2Encoder = commandEncoder.beginComputePass(computePassDescriptor);
            pass2Encoder.setPipeline(pass2ComputePipeline);
            pass2Encoder.setBindGroup(0, pass2UniformBindGroup);
            pass2Encoder.dispatchWorkgroups(1);
            pass2Encoder.end();


            const pass3Encoder = commandEncoder.beginComputePass(computePassDescriptor);
            pass3Encoder.setPipeline(pass3ComputePipeline);
            if (i % 2 == 0) {
                pass3Encoder.setBindGroup(0, pass3UniformBindGroup0);
            } else {
                pass3Encoder.setBindGroup(0, pass3UniformBindGroup1);
            }
            pass3Encoder.setBindGroup(1, pass13UniformBindGroupRadixIds[i]);
            pass3Encoder.dispatchWorkgroups(chunkCount);
            pass3Encoder.end();
        }</code></pre><p>we loop for 16 times, because we have 16 radix. Each time, we accomplish three passes. For the first and the third passes, we alternate the role of the input and output arrays, this is more efficient and avoid uncessary data copying. and finally, we read back the sorted array, I will skip the details.</p>
        </article>

        <div class="older_newer_link_section">
            <div class="older_newer_link_left">
                <p>
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M9.4 233.4c-12.5 12.5-12.5 32.8 0 45.3l160 160c12.5 12.5 32.8 12.5 45.3 0s12.5-32.8 0-45.3L109.2 288 416 288c17.7 0 32-14.3 32-32s-14.3-32-32-32l-306.7 0L214.6 118.6c12.5-12.5 12.5-32.8 0-45.3s-32.8-12.5-45.3 0l-160 160z" />
                    </svg>
                    PREV POST
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/Compute/prefix_sum.html">Prefix Sum</a>
                </p>
            </div>

            <div class="older_newer_link_right">
                <p>
                    NEXT POST
                    <svg xmlns="http://www.w3.org/2000/svg" height="12" width="11" fill="#dadadb"
                        viewBox="0 0 448 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
                        <path
                            d="M438.6 278.6c12.5-12.5 12.5-32.8 0-45.3l-160-160c-12.5-12.5-32.8-12.5-45.3 0s-12.5 32.8 0 45.3L338.8 224 32 224c-17.7 0-32 14.3-32 32s14.3 32 32 32l306.7 0L233.4 393.4c-12.5 12.5-12.5 32.8 0 45.3s32.8 12.5 45.3 0l160-160z" />
                    </svg>
                </p>
                <p>
                    <a class="older_newer_link" href="/WebGPUUnleashed/Compute/reaction_diffusion.html">Reaction Diffusion</a>
                </p>
            </div>
        </div>

        <a href="https://github.com/shi-yan/WebGPUUnleashed/discussions" target="_blank" class="comment"><svg
            style="margin-right:10px;vertical-align: middle;" xmlns="http://www.w3.org/2000/svg" height="32"
            width="32" fill="#dadadb"
            viewBox="0 0 480 512"><!--!Font Awesome Free 6.5.1 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free Copyright 2024 Fonticons, Inc.-->
            <path
                d="M186.1 328.7c0 20.9-10.9 55.1-36.7 55.1s-36.7-34.2-36.7-55.1 10.9-55.1 36.7-55.1 36.7 34.2 36.7 55.1zM480 278.2c0 31.9-3.2 65.7-17.5 95-37.9 76.6-142.1 74.8-216.7 74.8-75.8 0-186.2 2.7-225.6-74.8-14.6-29-20.2-63.1-20.2-95 0-41.9 13.9-81.5 41.5-113.6-5.2-15.8-7.7-32.4-7.7-48.8 0-21.5 4.9-32.3 14.6-51.8 45.3 0 74.3 9 108.8 36 29-6.9 58.8-10 88.7-10 27 0 54.2 2.9 80.4 9.2 34-26.7 63-35.2 107.8-35.2 9.8 19.5 14.6 30.3 14.6 51.8 0 16.4-2.6 32.7-7.7 48.2 27.5 32.4 39 72.3 39 114.2zm-64.3 50.5c0-43.9-26.7-82.6-73.5-82.6-18.9 0-37 3.4-56 6-14.9 2.3-29.8 3.2-45.1 3.2-15.2 0-30.1-.9-45.1-3.2-18.7-2.6-37-6-56-6-46.8 0-73.5 38.7-73.5 82.6 0 87.8 80.4 101.3 150.4 101.3h48.2c70.3 0 150.6-13.4 150.6-101.3zm-82.6-55.1c-25.8 0-36.7 34.2-36.7 55.1s10.9 55.1 36.7 55.1 36.7-34.2 36.7-55.1-10.9-55.1-36.7-55.1z" />
        </svg> Leave a Comment on Github</a>
    </div>
    <!-- The Modal -->
    <div id="img-modal" class="modal">
        <!-- The Close Button -->
        <span class="close" id="img-close">&times;</span>
        <!-- Modal Content (The Image) -->
        <img class="modal-content" id="img01">

        <!-- Modal Caption (Image Text) -->
        <div id="caption"></div>
    </div>
    <script>
        function fold(e) {
            const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            console.log("sub", e.currentTarget, sub);
            if (sub.style.display === "block") {
                sub.style.display = "none";
            } else {
                sub.style.display = "block";
            }
        }
    
        window.addEventListener('click', (e) => {
           // const sub = e.currentTarget.parentElement.getElementsByTagName("ul")[0];
            document.getElementById("menuButton").checked = false;
        });
    
        document.getElementById("menu-container").addEventListener('click',(event) => {
            event.stopPropagation();
        });

        document.getElementById("menuButton").addEventListener('click', (event) => {
            event.stopPropagation();
        });
       
        function openImage(img) {
            let modal = document.getElementById("img-modal");
            let modalImg = document.getElementById("img01");
            modal.style.display = "block";
            if (img.getAttribute("original_src")) {
                modalImg.src = img.getAttribute("original_src");
            } else {
                modalImg.src = img.src;
            }
            let captionText = document.getElementById("caption");

            captionText.innerText = img.alt;

            let sources = JSON.parse(img.getAttribute("sources"));

            for (let i = 0; i < sources.length; ++i) {
                if (sources.length == 1) {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE</a>";
                } else {
                    captionText.innerHTML += "<a href='" + sources[i] + "' target='_blank' class='img-source'>SOURCE " + (i + 1) + "</a>";
                }
            }
        }
        // Get the <span> element that closes the modal
        var closeButton = document.getElementById("img-close");

        // When the user clicks on <span> (x), close the modal
        closeButton.onclick = function () {
            var modal = document.getElementById("img-modal");
            modal.style.display = "none";
        }
    </script>

    <script type="module">
        const macros = {};
        const mathElementsBlock = document.getElementsByClassName("math-block");
        for (let element of mathElementsBlock) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                displayMode: true,
                macros
            });
        }

        const mathElementsInline = document.getElementsByClassName("math-inline");
        for (let element of mathElementsInline) {
            katex.render(element.textContent, element, {
                throwOnError: false,
                macros
            });
        }

        hljs.highlightAll();
        // hljs.initLineNumbersOnLoad();
        const codeBlocks = document.getElementsByClassName("code-block");
        for (let i = 0; i < codeBlocks.length; ++i) {
            if (codeBlocks[i].hasAttribute("startnumber")) {
                const startFrom = codeBlocks[i].getAttribute("startnumber");
                hljs.lineNumbersBlock(codeBlocks[i], { startFrom: parseInt(startFrom, 10) });
            } else {
                hljs.lineNumbersBlock(codeBlocks[i]);
            }
        }

    </script>
</body>

</html>